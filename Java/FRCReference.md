# FRC Java / WPILib Quick Reference Guide — 2026 Season

---

## Table of Contents
1. [Project Structure](#1-project-structure)
2. [Robot Base Classes](#2-robot-base-classes)
3. [Command-Based Programming](#3-command-based-programming)
4. [Subsystems](#4-subsystems)
5. [Commands](#5-commands)
6. [Triggers & Default Commands](#6-triggers--default-commands)
7. [Motor Controllers](#7-motor-controllers)
8. [Sensors](#8-sensors)
9. [Joysticks & Controllers](#9-joysticks--controllers)
10. [Drivetrain Types](#10-drivetrain-types)
11. [PID Control](#11-pid-control)
12. [PathPlanner & Autonomous](#12-pathplanner--autonomous)
13. [SmartDashboard & Shuffleboard](#13-smartdashboard--shuffleboard)
14. [NetworkTables](#14-networktables)
15. [Vision (Limelight & PhotonVision)](#15-vision-limelight--photonvision)
16. [Pneumatics](#16-pneumatics)
17. [CAN Bus & Power Distribution](#17-can-bus--power-distribution)
18. [Robot Simulation](#18-robot-simulation)
19. [Vendor Libraries Cheatsheet](#19-vendor-libraries-cheatsheet)
20. [Common Gotchas & Best Practices](#20-common-gotchas--best-practices)

---

## 1. Project Structure

WPILib projects are built with **Gradle**, a JVM-based build tool. You never need to manage classpaths or JAR files manually — Gradle fetches everything from Maven repositories automatically when you run a build or deploy.

A standard WPILib project generated by VS Code looks like this:

```
MyRobot/
├── src/main/java/frc/robot/
│   ├── Main.java               // Entry point — do NOT touch this
│   ├── Robot.java              // Top-level robot class (TimedRobot or CommandRobot)
│   ├── RobotContainer.java     // Wires subsystems + commands + button bindings
│   ├── Constants.java          // All magic numbers live here
│   ├── commands/               // One file per Command
│   └── subsystems/             // One file per Subsystem
├── src/main/deploy/            // Files deployed to RoboRIO (e.g., PathPlanner paths)
├── vendordeps/                 // JSON files for third-party libraries (CTRE, REV, etc.)
└── build.gradle                // Build config — add vendor deps here
```

**What each file does:**
- `Main.java` — Bootstraps the HAL (Hardware Abstraction Layer) and starts the robot loop. Never modify this.
- `Robot.java` — The top-level class. Extends `TimedRobot` or `RobotBase`. Defines mode-transition callbacks (`autonomousInit`, `teleopPeriodic`, etc.).
- `RobotContainer.java` — The "wiring hub." Instantiates all subsystems and commands, then connects them to controller buttons. Keeps `Robot.java` clean.
- `Constants.java` — Centralizes every magic number (CAN IDs, gear ratios, PID gains, port numbers). If a number appears more than once in code, it belongs here.
- `vendordeps/` — Each `.json` file tells Gradle where to download a vendor library (CTRE, REV, etc.). Install via the WPILib VS Code palette, not by hand.

**Constants.java pattern:**
```java
public final class Constants {
    // Nest constants in inner classes by subsystem to avoid name collisions.
    // Using nested static classes (not enums) means you can use them as
    // compile-time constants with 'public static final'.
    public static final class DriveConstants {
        public static final int kFrontLeftMotorID = 1;
        public static final int kFrontRightMotorID = 2;
        public static final double kMaxSpeedMetersPerSecond = 4.5;
    }

    public static final class OperatorConstants {
        public static final int kDriverControllerPort = 0;
    }
}
```

> **Why nest?** If you have `DriveConstants.kP` and `ShooterConstants.kP`, there's no ambiguity, no long prefix names, and auto-import works cleanly.

---

## 2. Robot Base Classes

### TimedRobot (simplest, no command framework)

`TimedRobot` is the simplest base class. It uses an **interrupt-driven 20 ms timer** to call your periodic methods. The RoboRIO's FPGA (Field Programmable Gate Array) keeps this timing extremely precise — you don't need to manage threading.

The robot's `robotPeriodic()` and mode-specific periodic methods are called every **20 ms** by the scheduler loop.

```java
public class Robot extends TimedRobot {

    @Override
    public void robotInit() {
        // Runs once when robot code starts (power on or code deploy).
        // Initialize hardware, set up subsystems, configure auto chooser.
    }

    @Override
    public void robotPeriodic() {
        // Runs every 20 ms regardless of mode — good for telemetry.
        // If using Command-Based, this MUST call CommandScheduler.getInstance().run()
        // so that all active commands execute each loop.
        CommandScheduler.getInstance().run();
    }

    @Override
    public void autonomousInit()    {
        // Runs ONCE when the robot transitions into autonomous mode.
        // Fetch and schedule your auto command here.
    }
    @Override
    public void autonomousPeriodic(){
        // Runs every 20 ms in auto. With Command-Based, leave this empty;
        // the Scheduler (called in robotPeriodic) handles everything.
    }

    @Override
    public void teleopInit()        {
        // Runs ONCE when teleop begins. Cancel any lingering auto commands here.
        // Example: m_autonomousCommand.cancel();
    }
    @Override
    public void teleopPeriodic()    {
        // Runs every 20 ms in teleop. Again, usually empty with Command-Based.
    }

    @Override
    public void disabledInit()      {
        // Runs once when robot is disabled (e.g., match end, E-stop).
        // Good place to stop any ongoing motion or logging.
    }
    @Override
    public void disabledPeriodic()  {
        // Runs every 20 ms while disabled.
        // Useful for updating dashboard values and letting operators set up for next mode.
    }

    @Override
    public void testInit()          { }
    @Override
    public void testPeriodic()      { }
    // Test mode is enabled from the Driver Station; use it for manual hardware checks.
}
```

**Key concepts:**
- All `*Periodic()` methods run on the **main robot thread** — never block with `Thread.sleep()`. Blocking for even a few milliseconds will cause a loop overrun warning and unpredictable behavior.
- The 20 ms loop period can be changed with `super.setPeriod(0.02)` in `robotInit()`. Most teams leave it at 20 ms; some use 10 ms for tighter control loops.
- `TimedRobot` is perfectly fine for simple robots — you don't *have* to use Command-Based.
- The order of calls each loop: `robotPeriodic()` → mode-specific periodic (e.g., `teleopPeriodic()`). Mode `*Init()` methods run exactly once on mode transition.

---

## 3. Command-Based Programming

Command-Based is WPILib's recommended framework for organizing robot code. It enforces a clean separation between *what the robot can do* (Subsystems) and *instructions for when and how to do it* (Commands). This makes it easy to reuse actions, compose complex behaviors, and avoid hardware conflicts without writing manual state machines.

### Core idea
```
Subsystem  — owns hardware, has actions (methods)
Command    — uses one or more Subsystems, has lifecycle methods (init/execute/end/isFinished)
Scheduler  — runs all active Commands every loop; handles conflicts via Requirements
```

**How conflict resolution works:** When a new Command is scheduled, the Scheduler checks which Subsystems it `requires`. If another Command already holds one of those Subsystems, the old Command is **interrupted** (its `end(true)` is called) and the new Command takes over. This prevents two commands from fighting over the same motor. The only exception is if the running command is marked `withInterruptBehavior(InterruptionBehavior.kCancelIncoming)`, which causes the new command to be rejected instead.

### RobotContainer.java (the wiring hub)
```java
public class RobotContainer {
    // Subsystems are created here (or imported from a singleton).
    // Creating them here ensures they're initialized before any bindings.
    private final DriveSubsystem m_drive = new DriveSubsystem();
    private final IntakeSubsystem m_intake = new IntakeSubsystem();

    // Controllers
    private final XboxController m_driverController =
        new XboxController(OperatorConstants.kDriverControllerPort);

    public RobotContainer() {
        configureBindings();

        // Set default command for drive subsystem (runs when no other command needs it).
        // Lambda suppliers pull the axis values each loop — no stale data.
        m_drive.setDefaultCommand(
            new ArcadeDriveCommand(m_drive,
                () -> -m_driverController.getLeftY(),   // throttle
                () ->  m_driverController.getRightX())  // turn
        );
    }

    private void configureBindings() {
        // Run intake while A button is held; automatically cancels when released.
        new JoystickButton(m_driverController, XboxController.Button.kA.value)
            .whileTrue(new IntakeCommand(m_intake));

        // Toggle arm on B button press — each press flips the state.
        new JoystickButton(m_driverController, XboxController.Button.kB.value)
            .toggleOnTrue(new ArmUpCommand(m_arm));
    }

    // Called by Robot.java to get the auto command selected on the dashboard.
    public Command getAutonomousCommand() {
        return new ExampleAutoCommand(m_drive);
    }
}
```

---

## 4. Subsystems

A Subsystem is the **owner** of a piece of hardware. Only one Subsystem should ever write to a given motor controller, sensor, or actuator. This ownership contract is what allows the Command Scheduler to safely manage conflicts.

Subsystems extend `SubsystemBase`, which automatically registers them with the Scheduler so their `periodic()` method is called every loop.

```java
import edu.wpi.first.wpilibj2.command.SubsystemBase;

public class DriveSubsystem extends SubsystemBase {

    // Hardware fields are PRIVATE — outside code can only interact through methods.
    // This prevents random code from setting motor voltages directly.
    private final WPI_TalonFX m_leftMotor  = new WPI_TalonFX(DriveConstants.kFrontLeftMotorID);
    private final WPI_TalonFX m_rightMotor = new WPI_TalonFX(DriveConstants.kFrontRightMotorID);
    private final DifferentialDrive m_drive;

    public DriveSubsystem() {
        // Right side motors face opposite direction on most drivetrains.
        // Forgetting this causes the robot to spin in circles.
        m_rightMotor.setInverted(true);
        m_drive = new DifferentialDrive(m_leftMotor, m_rightMotor);
    }

    // Action methods are simple and stateless — they just pass values to hardware.
    // The Command decides WHEN to call them and with what values.
    public void arcadeDrive(double speed, double rotation) {
        m_drive.arcadeDrive(speed, rotation);
    }

    public void stopDrive() {
        m_drive.stopMotor();
    }

    @Override
    public void periodic() {
        // Called every 20 ms by the scheduler automatically (no manual call needed).
        // Use this for: reading sensors, updating odometry, publishing telemetry.
        // Do NOT put game logic here — that belongs in Commands.
        SmartDashboard.putNumber("Left Encoder", m_leftMotor.getSelectedSensorPosition());
    }
}
```

**Rules for Subsystems:**
- Never put game logic inside `periodic()` — that belongs in Commands. `periodic()` should only do bookkeeping (odometry updates, telemetry, etc.).
- Hardware (motors, sensors) should be `private` fields — expose only methods. This makes it obvious which subsystem "owns" each piece of hardware.
- Each piece of hardware should belong to **exactly one** Subsystem. If two subsystems need to coordinate, use a Command that requires both.
- `simulationPeriodic()` is a second override available for simulation-only logic (physics updates, sim sensor injection). It runs alongside `periodic()` only in simulation mode.
- **New in 2026:** `subsystem.idle()` returns a no-op `InstantCommand` that still requires the subsystem. Use it as a default command placeholder or to hold a subsystem without doing anything: `m_arm.setDefaultCommand(m_arm.idle());`

---

## 5. Commands

Commands are the **active logic** of your robot. Each Command defines what to do with one or more Subsystems, and the Scheduler calls its lifecycle methods every loop. Commands are designed to be **composable** — you can chain and nest them rather than writing long procedural auto routines.

Commands have four lifecycle methods:

```java
import edu.wpi.first.wpilibj2.command.Command;

public class IntakeCommand extends Command {

    private final IntakeSubsystem m_intake;

    public IntakeCommand(IntakeSubsystem intake) {
        m_intake = intake;
        // addRequirements() tells the Scheduler this Command "owns" the intake.
        // If another Command tries to use the intake, this one will be interrupted.
        // Forgetting this call means two Commands can fight over hardware silently.
        addRequirements(intake);
    }

    @Override
    public void initialize() {
        // Runs ONCE when the command is first scheduled.
        // Use this to set initial state: start a timer, move to a start position, etc.
        m_intake.setSpeed(0.8);
    }

    @Override
    public void execute() {
        // Runs every 20 ms while the command is active.
        // Use this for continuous control: reading joystick input, running a PID loop, etc.
        // For simple commands (like "run intake at constant speed"), this can be empty.
    }

    @Override
    public void end(boolean interrupted) {
        // Runs ONCE when the command ends, whether normally (isFinished returned true)
        // or because it was interrupted by another command or manually cancelled.
        // 'interrupted' is true if cancelled externally, false if it finished on its own.
        // Always clean up here: stop motors, retract mechanisms, etc.
        m_intake.stop();
    }

    @Override
    public boolean isFinished() {
        // Checked every loop. Return true to end the command normally.
        // Return false to keep running indefinitely (until interrupted).
        // Examples: return m_intake.hasNote(); — ends when game piece is detected
        //           return m_timer.hasElapsed(2.0); — ends after 2 seconds
        return false;  // false = run forever until interrupted
    }
}
```

> **2026 deprecation:** `command.schedule()` (calling `.schedule()` directly on a Command object) is deprecated. Use `CommandScheduler.getInstance().schedule(command)` instead, or bind to a Trigger/button which schedules it automatically. The instance method will be removed in 2027.

### Inline Commands (lambda-based, no separate file needed)

For simple one-liner actions you don't need a full class. These are ideal for button bindings and auto compositions.

```java
// RunCommand — runs execute() every loop forever (isFinished always false).
// Good for: "run this continuously while button is held"
new RunCommand(() -> m_intake.setSpeed(0.8), m_intake);

// InstantCommand — runs once then finishes immediately (isFinished always true after init).
// Good for: toggling a solenoid, resetting a sensor, zeroing a position.
new InstantCommand(() -> m_intake.stop(), m_intake);

// StartEndCommand — runs a lambda on init, a different one on end.
// Equivalent to a Command with initialize() and end() but no execute().
new StartEndCommand(
    () -> m_intake.setSpeed(0.8),  // initialize
    () -> m_intake.stop(),         // end
    m_intake
);

// FunctionalCommand — full control with lambdas, equivalent to a complete Command class.
// Use when you need execute() or isFinished() logic but don't want a separate file.
new FunctionalCommand(
    () -> m_intake.setSpeed(0.8),     // initialize
    () -> {},                          // execute (empty here)
    interrupted -> m_intake.stop(),   // end (gets the interrupted boolean)
    () -> m_intake.isAtLimit(),       // isFinished — ends when limit is hit
    m_intake
);
```

### Command Composition (chaining commands together)

Command groups let you build complex auto routines from simple reusable pieces. The Scheduler treats a group as a single Command — it can be interrupted as a unit, and all sub-commands share requirements correctly.

```java
// Sequential: run commands one after another (each must finish before next starts).
// Most common for auto routines: drive, then turn, then score.
new SequentialCommandGroup(
    new DriveForwardCommand(m_drive, 1.0),  // drives 1 meter
    new TurnCommand(m_drive, 90),           // turns 90 degrees
    new IntakeCommand(m_intake)             // then intakes
);

// Parallel: run commands at the same time, finish when ALL are done.
// Good for: raising an arm while extending the wrist simultaneously.
new ParallelCommandGroup(
    new ArmUpCommand(m_arm),
    new ExtendWristCommand(m_wrist)
);

// Parallel race: run commands at same time, end when the FIRST one finishes.
// All others are interrupted. Great for timeout safety.
new ParallelRaceGroup(
    new IntakeCommand(m_intake),
    new WaitCommand(2.0)    // intake for max 2 seconds, whichever comes first
);

// Parallel deadline: like race, but YOU choose which command is the "deadline".
// The others run until the deadline finishes; useful when the main task has a fixed duration.
new ParallelDeadlineGroup(
    new WaitCommand(3.0),      // deadline — defines total time
    new DriveForwardCommand(m_drive),
    new IntakeCommand(m_intake)
);

// Fluent chaining (cleaner syntax, same behavior as groups above):
driveForward.andThen(turn).andThen(intake);     // sequential
driveForward.alongWith(armUp);                  // parallel (all finish)
driveForward.raceWith(new WaitCommand(5.0));    // parallel race
driveForward.withTimeout(5.0);                  // shorthand for race with WaitCommand
driveForward.onlyIf(() -> condition);           // only runs if condition is true when scheduled
driveForward.repeatedly();                      // loops the command forever (resets on end)
```

---

## 6. Triggers & Default Commands

Triggers are the **glue** between controller inputs (or any boolean condition) and Commands. Rather than checking button states inside `teleopPeriodic()`, you declare bindings once in `configureBindings()` and the Scheduler handles the rest. This keeps the code declarative and makes it easy to see all control mappings in one place.

### Button Bindings
```java
JoystickButton btn = new JoystickButton(controller, XboxController.Button.kA.value);

btn.onTrue(command);          // Schedule once when button is pressed. Does NOT cancel on release.
btn.onFalse(command);         // Schedule once when button is released (button-up event).
btn.whileTrue(command);       // Schedule when pressed; cancel the command when released.
btn.whileFalse(command);      // Schedule when not pressed; cancel when pressed.
btn.toggleOnTrue(command);    // First press: schedule. Second press: cancel. Alternates each press.
btn.toggleOnFalse(command);   // Same but triggers on button release.
```

> **onTrue vs whileTrue:** `onTrue` fires the command once and lets it run until `isFinished()` returns true — the button release doesn't matter. `whileTrue` ties the command's lifetime to the button: it cancels the moment you let go, regardless of `isFinished()`.

### Trigger from any boolean condition

Triggers aren't limited to physical buttons — they can wrap any `BooleanSupplier`, which is any function returning true/false. This is extremely powerful for sensor-driven automation.

```java
// Custom trigger — fires when intake sensor detects a game piece.
// The Scheduler polls this lambda every loop.
Trigger intakeSensor = new Trigger(() -> m_intake.hasNote());
intakeSensor.onTrue(new RumbleCommand(m_controller));

// Triggers can be composed with logical operators:
Trigger highSpeed   = new Trigger(() -> m_drive.getSpeed() > 3.0);
Trigger hasNote     = new Trigger(() -> m_intake.hasNote());
Trigger readyToShoot = hasNote.and(highSpeed.negate());  // has note AND not going fast
readyToShoot.onTrue(new SpinUpShooterCommand(m_shooter));

// Trigger from SmartDashboard boolean (lets drivers toggle features from the dashboard):
Trigger dashTrigger = new Trigger(
    NetworkButton.fromSmartDashboard("Enable Shooter")
);
```

### Default Commands

A Default Command runs on a Subsystem **whenever no other Command requires it**. It is automatically re-scheduled after any interrupting Command finishes. The most common use is driving: the drive subsystem's default command reads joystick input, but any auto command can temporarily take over.

```java
// Runs when no other command requires this subsystem.
// The lambda captures the controller reference, so values are read fresh every loop.
m_drive.setDefaultCommand(
    new ArcadeDriveCommand(m_drive,
        () -> -m_driver.getLeftY(),
        () ->  m_driver.getRightX())
);
```

> **Important:** Default Commands must NOT have an `isFinished()` that returns true, or they'll complete immediately and won't act as a fallback. They should run forever (return false) and rely on interruption for stopping.

---

## 7. Motor Controllers

FRC teams primarily use CAN bus motor controllers, which communicate via a two-wire CAN network rather than PWM signals. CAN controllers support onboard PID, encoder feedback, and status telemetry. Each device needs a **unique CAN ID** (0–62).

### CTRE TalonFX (Falcon 500 / Kraken X60)

The TalonFX is a brushless motor controller with an integrated encoder (2048 ticks/rev for Falcon, 4096 for Kraken). Phoenix 6 (the current API) communicates over a high-speed CAN protocol and supports onboard PID running at 1 kHz — far faster than the 50 Hz robot loop.

```java
import com.ctre.phoenix6.hardware.TalonFX;
import com.ctre.phoenix6.controls.*;
import com.ctre.phoenix6.configs.*;

TalonFX motor = new TalonFX(1);  // CAN ID 1 (on default "rio" CAN bus)
// Note: new TalonFX(1, "canivore1") String-based constructor is deprecated in 2026.
// Use the CANBus object constructor for CANivore (see Section 17).

// Basic output — percent of battery voltage, -1.0 to 1.0.
motor.set(0.5);  // 50% duty cycle

// Configuration (Phoenix 6 — applied via Configurator, not individual set calls)
TalonFXConfiguration config = new TalonFXConfiguration();
config.MotorOutput.NeutralMode = NeutralModeValue.Brake;  // Brake or Coast when output is 0
config.MotorOutput.Inverted    = InvertedValue.Clockwise_Positive;  // Which direction is "positive"
config.CurrentLimits.SupplyCurrentLimit        = 40;   // Max amps from battery supply
config.CurrentLimits.SupplyCurrentLimitEnable  = true; // Must enable to take effect
// CurrentLimits protect wiring and breakers. Stator limits protect the motor itself.
motor.getConfigurator().apply(config);  // Apply all config at once — more efficient than per-call

// Position control (Phoenix 6 control requests) — runs PID at 1 kHz on the controller
// Slot 0 is the default PID slot; configure gains in config.Slot0.kP, kI, kD, kV, kS
PositionVoltage posReq = new PositionVoltage(0).withSlot(0);
motor.setControl(posReq.withPosition(10.0));  // Move to 10 rotations from zero

// Velocity control — useful for flywheels and rollers
VelocityVoltage velReq = new VelocityVoltage(0).withSlot(0);
motor.setControl(velReq.withVelocity(50.0));  // Target 50 rotations/sec

// Follower — mirrors the master's output automatically, even across CAN bus.
// 'true' for oppose direction (right-side follower that needs inversion)
TalonFX follower = new TalonFX(2);
follower.setControl(new Follower(motor.getDeviceID(), true));

// Read position/velocity (Phoenix 6 uses StatusSignals for low-latency reads)
double position = motor.getPosition().getValueAsDouble(); // rotations
double velocity = motor.getVelocity().getValueAsDouble(); // rotations/sec
```

### REV SparkMAX (NEO, NEO 550)

The SparkMAX controls REV NEO and NEO 550 brushless motors. Unlike TalonFX, the motor and controller are **separate** — the SparkMAX is the controller box you wire to. It has an onboard PID that also runs at 1 kHz.

```java
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkBase.IdleMode;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkPIDController;

CANSparkMax motor = new CANSparkMax(1, CANSparkMax.MotorType.kBrushless);

// Configuration — ALWAYS restore factory defaults first to clear any leftover settings
// from previous deploys. Configuration order matters; apply before burnFlash().
motor.restoreFactoryDefaults();
motor.setIdleMode(IdleMode.kBrake);  // kBrake stops quickly; kCoast lets it freewheel
motor.setInverted(false);            // true = positive output → motor shaft turns opposite direction
motor.setSmartCurrentLimit(40);      // soft current limit in amps (motor-side stator current)
motor.burnFlash();                   // Persist configuration to flash memory (survives power cycle)

// Basic output
motor.set(0.5);  // -1.0 to 1.0

// Built-in relative encoder (NEO: 42 counts/rev before gear ratio)
RelativeEncoder encoder = motor.getEncoder();
// Conversion factors map raw units to your desired units:
encoder.setPositionConversionFactor(/* meters per rotation */ 0.0508 * Math.PI / 6.75);
encoder.setVelocityConversionFactor(/* m/s per RPM */         0.0508 * Math.PI / 6.75 / 60.0);
double pos = encoder.getPosition(); // in converted units (meters if set above)
double vel = encoder.getVelocity(); // in converted units (m/s if set above)

// Onboard PID (runs on SparkMAX itself at 1 kHz, not in robot loop)
SparkPIDController pid = motor.getPIDController();
pid.setP(0.1);   // Proportional gain — main driver of error correction
pid.setI(0.0);   // Integral gain — corrects steady-state error (use sparingly)
pid.setD(0.01);  // Derivative gain — dampens oscillation
pid.setFF(0.0);  // Feedforward — adds open-loop contribution based on setpoint
pid.setReference(100, CANSparkMax.ControlType.kVelocity); // RPM target
pid.setReference(10,  CANSparkMax.ControlType.kPosition); // Rotation target

// Follower — the follower mirrors the leader's output automatically
CANSparkMax follower = new CANSparkMax(2, CANSparkMax.MotorType.kBrushless);
follower.follow(motor, true);  // true = invert follower relative to leader
```

### REV SparkFlex (NEO Vortex)

The SparkFlex is the successor to the SparkMAX, designed for the NEO Vortex motor. It has higher current capacity and improved thermal performance. The API is nearly identical to SparkMAX.

```java
// Almost identical to SparkMAX — same configuration methods, same PID controller API.
import com.revrobotics.CANSparkFlex;
CANSparkFlex motor = new CANSparkFlex(1, CANSparkFlex.MotorType.kBrushless);
// Same API as SparkMAX — restoreFactoryDefaults(), setIdleMode(), burnFlash(), etc.
```

### Victor SPX / Talon SRX (older CTRE)

These are Phoenix 5 (legacy) controllers. The Talon SRX supports sensor feedback (encoders, limit switches) directly. The Victor SPX is output-only (no encoder input). Both use the older Phoenix 5 API, which has a different configuration style than Phoenix 6.

```java
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import com.ctre.phoenix.motorcontrol.NeutralMode;

WPI_TalonSRX talon = new WPI_TalonSRX(1);
talon.setNeutralMode(NeutralMode.Brake);  // NeutralMode.Coast also available
talon.setInverted(false);
talon.set(0.5);  // percent output (-1.0 to 1.0)

WPI_VictorSPX victor = new WPI_VictorSPX(2);
victor.follow(talon);  // Victor mirrors Talon output
```

### PWM Motor Controllers (Spark, Talon, Victor — non-CAN)

PWM (Pulse Width Modulation) controllers use a single signal wire and don't support encoder feedback or onboard PID. They're simpler and cheaper but lack the telemetry and control features of CAN. Use them for low-priority mechanisms like intake rollers or climbers where you don't need precision.

```java
import edu.wpi.first.wpilibj.motorcontrol.Spark;
import edu.wpi.first.wpilibj.motorcontrol.PWMTalonFX;
import edu.wpi.first.wpilibj.motorcontrol.VictorSP;

Spark spark = new Spark(0);     // PWM port 0 on RoboRIO (ports 0–9)
spark.set(0.5);                 // -1.0 to 1.0
spark.setInverted(true);        // Flip positive direction
spark.stopMotor();              // Set to 0
```

---

## 8. Sensors

Sensors provide the robot with feedback about its state and environment. Reliable sensors are the foundation of autonomous control — without good sensor data, PID and path following fall apart.

### Encoders (general WPILib)

Quadrature encoders use two channels (A and B) with a known phase relationship to detect both position and direction. The pulse count increases or decreases depending on which channel leads. Common counts per revolution: 256, 1024, 2048. After setting `setDistancePerPulse`, all reads return your chosen unit (meters, rotations, etc.).

```java
import edu.wpi.first.wpilibj.Encoder;

// Quadrature encoder on DIO ports.
// Channel A and B must match your physical wiring — swapping them reverses direction.
Encoder enc = new Encoder(0, 1);                   // channel A=0, B=1
enc.setDistancePerPulse(Math.PI * 0.1524 / 2048);  // wheel circumference / pulses per rev
enc.setReverseDirection(false);                     // true = flip direction

double distance = enc.getDistance();  // in your units (meters if set above)
double rate     = enc.getRate();      // units/sec (derivative of distance — velocity)
int    raw      = enc.get();          // raw pulse count since last reset
enc.reset();                          // zero the encoder — call at the start of each auto
```

### Gyroscopes

Gyroscopes measure rotational rate (degrees per second) and integrate it over time to give heading. All gyros drift slightly — the longer they run, the more error accumulates. Fusing gyro with vision (or wheel odometry) corrects drift. Always **wait for calibration** before zeroing.

**NavX (AHRS) — most common FRC gyro:**

> **2026 package change:** The NavX library is now published by **Studica Robotics** (`StudicaLib`). The import changed from `com.kauailabs.navx.frc.AHRS` → `com.studica.frc.AHRS`. Update your vendordep URL and imports when migrating from 2025. The old `Studica` and new `StudicaLib` vendordeps **cannot be installed at the same time**.

```java
import com.studica.frc.AHRS;  // 2026: was com.kauailabs.navx.frc.AHRS
import edu.wpi.first.wpilibj.SPI;

// NavX mounts on the RoboRIO's MXP port.
// On boot it takes ~1–2 seconds to calibrate (isCalibrating() returns true during this).
AHRS gyro = new AHRS(SPI.Port.kMXP);

double angle    = gyro.getAngle();         // Cumulative angle (degrees). Can exceed ±360.
                                            // Positive = counterclockwise by convention.
double yaw      = gyro.getYaw();           // -180 to 180, wraps around.
double pitch    = gyro.getPitch();         // Tilt front-to-back (degrees)
double roll     = gyro.getRoll();          // Tilt side-to-side (degrees)
double rate     = gyro.getRate();          // Degrees/sec (instantaneous turn rate)
gyro.reset();                              // Zero angle and yaw to current heading
gyro.zeroYaw();                            // Zero only yaw (keeps other readings intact)
boolean isCalib = gyro.isCalibrating();    // Wait for false before zeroing at robotInit
```

**Pigeon 2 (CTRE):**

The Pigeon 2 connects over CAN bus (rather than the MXP port), making wiring cleaner on CAN-heavy robots. It uses Phoenix 6 StatusSignal reads for low-latency data.

```java
import com.ctre.phoenix6.hardware.Pigeon2;

Pigeon2 pigeon = new Pigeon2(0);  // CAN ID 0
double yaw   = pigeon.getYaw().getValueAsDouble();   // degrees, continuous (not wrapped)
double pitch = pigeon.getPitch().getValueAsDouble();
double roll  = pigeon.getRoll().getValueAsDouble();
pigeon.reset();
// Get as Rotation2d for use with WPILib's kinematics/odometry (expects Rotation2d):
Rotation2d heading = Rotation2d.fromDegrees(pigeon.getYaw().getValueAsDouble());
```

### Limit Switches

Limit switches are simple digital (on/off) sensors that detect a mechanism reaching a physical endpoint. Most are normally-closed (NC), meaning they read `true` when not pressed and `false` when triggered — hence the inversion. Use them to prevent motors from overdriving past safe limits.

```java
import edu.wpi.first.wpilibj.DigitalInput;

DigitalInput limitSwitch = new DigitalInput(0);  // DIO port 0 on RoboRIO
// Normally-closed switches return false when activated (circuit broken by pressing).
boolean isTriggered = !limitSwitch.get();        // Invert for NC wiring
```

### Analog Sensors (potentiometers, pressure sensors, ultrasonic)

Analog sensors output a variable voltage (0–5V) proportional to a physical quantity. The RoboRIO has a 12-bit ADC (analog-to-digital converter), so raw readings range from 0 to 4095. Pressure sensors and ultrasonic distance sensors are common examples.

```java
import edu.wpi.first.wpilibj.AnalogInput;

AnalogInput sensor = new AnalogInput(0);  // Analog port 0 (ports 0–3 on RoboRIO)
double voltage    = sensor.getVoltage();  // 0–5V
double normalized = sensor.getValue();    // 0–4095 (12-bit ADC raw count)
// Convert voltage to physical units using your sensor's datasheet formula.
// Example for REV Analog Pressure Sensor: pressure = 250 * voltage / 5.0 - 25;
```

### Through-Bore Encoder (REV)

The REV Through-Bore Encoder is an absolute encoder — it knows its position even after a power cycle, without needing to home the mechanism. It outputs a PWM duty cycle signal read on a DIO port. Position ranges 0.0–1.0 (full rotation). Use it for pivoting arms and wrist mechanisms where you need to know angle at startup.

```java
// Plugged into DIO — use as absolute encoder for absolute position
import edu.wpi.first.wpilibj.DutyCycleEncoder;

DutyCycleEncoder absEnc = new DutyCycleEncoder(0);  // DIO port
// Offset: the 0.0–1.0 value that corresponds to your "zero" position.
// Measure this once physically and put it in Constants.java.
absEnc.setPositionOffset(0.5);   // The encoder reads 0.5 when mechanism is at zero
double absPosition = absEnc.getAbsolutePosition();   // 0.0 to 1.0 (fraction of full rotation)
double position    = absEnc.get();                   // Rotations offset from zero position
```

### Color Sensor (REV)

The REV Color Sensor V3 measures reflected light color and proximity over I2C. Useful for detecting game pieces or field elements by their color. Proximity uses an infrared LED — higher values mean closer objects.

```java
import com.revrobotics.ColorSensorV3;
import edu.wpi.first.wpilibj.I2C;

ColorSensorV3 colorSensor = new ColorSensorV3(I2C.Port.kOnboard);
Color color     = colorSensor.getColor();         // Returns normalized R/G/B values (0.0–1.0)
int proximity   = colorSensor.getProximity();     // 0–2047 — higher = closer to sensor
// Compare color to known targets using ColorMatchResult and ColorMatch class.
```

---

## 9. Joysticks & Controllers

All controller input goes through the Driver Station software on a laptop, which sends HID (Human Interface Device) data to the robot over the field network (or USB during practice). The RoboRIO receives it via NetworkTables and WPILib's joystick layer.

### XboxController (most common)
```java
import edu.wpi.first.wpilibj.XboxController;

XboxController controller = new XboxController(0);  // Port 0 = first controller in DS

// Axes return -1.0 to 1.0. Note: Y axes are negated by convention because
// physically pushing the stick UP returns a NEGATIVE value from the hardware.
double leftY  = -controller.getLeftY();   // Negate! Up = negative by default
double leftX  =  controller.getLeftX();
double rightY = -controller.getRightY();
double rightX =  controller.getRightX();
double leftTrigger  = controller.getLeftTriggerAxis();   // 0 to 1 (analog, not a button)
double rightTrigger = controller.getRightTriggerAxis();  // 0 to 1

// Buttons return boolean (true = currently held)
boolean aBtn  = controller.getAButton();
boolean bBtn  = controller.getBButton();
boolean xBtn  = controller.getXButton();
boolean yBtn  = controller.getYButton();
boolean lb    = controller.getLeftBumper();
boolean rb    = controller.getRightBumper();
boolean start = controller.getStartButton();
boolean back  = controller.getBackButton();

// D-Pad (POV — Point of View hat switch).
// Returns -1 when not pressed; 0=up, 90=right, 180=down, 270=left.
// Diagonals: 45, 135, 225, 315. Treat with == comparisons only.
int pov = controller.getPOV();

// Rumble — feedback to the driver (e.g., when a game piece is acquired)
controller.setRumble(XboxController.RumbleType.kBothRumble, 1.0);  // 0 to 1 intensity
controller.setRumble(XboxController.RumbleType.kBothRumble, 0.0);  // Stop rumble

// For Command-Based bindings use CommandXboxController instead.
// It wraps axes in Triggers automatically, enabling .whileTrue(), .onTrue(), etc.
// Use this in RobotContainer — don't use raw XboxController for bindings.
import edu.wpi.first.wpilibj2.command.button.CommandXboxController;
CommandXboxController cmdCtrl = new CommandXboxController(0);
cmdCtrl.a().whileTrue(new IntakeCommand(m_intake));
cmdCtrl.b().onTrue(new InstantCommand(m_intake::stop));
cmdCtrl.leftBumper().whileTrue(new ShootCommand(m_shooter));
cmdCtrl.povUp().onTrue(new ArmUpCommand(m_arm));
```

### PS4 / Generic Joystick
```java
import edu.wpi.first.wpilibj.PS4Controller;
PS4Controller ps4 = new PS4Controller(1);  // Port 1
double leftY = -ps4.getLeftY();  // Same Y-axis negate convention

// Generic Joystick — use when you don't know the controller type ahead of time.
// Access axes by index (check your DS HID page for mapping).
import edu.wpi.first.wpilibj.Joystick;
Joystick stick = new Joystick(0);
double x = stick.getX();
double y = stick.getY();
boolean trigger = stick.getTrigger();  // Button 1
boolean btn2    = stick.getRawButton(2);
```

### Deadband (important — joysticks have drift!)

Physical joysticks never truly return to zero — there's always a small voltage offset even when you're not touching them. Without a deadband, a robot will slowly creep when the driver lets go of the stick. A deadband zeros out any input smaller than a threshold.

```java
import edu.wpi.first.math.MathUtil;

double input = controller.getLeftY();
// applyDeadband: values within ±0.1 become 0; values outside scale to fill the full range.
// This means 0.1 maps to 0 and 1.0 maps to 1.0 (no sudden jump at the threshold).
double deadzoned = MathUtil.applyDeadband(input, 0.1);

// Manual deadband (simpler, but causes a discontinuity at the threshold edge):
double deadbanded = Math.abs(input) < 0.1 ? 0.0 : input;
```

---

## 10. Drivetrain Types

Choosing the right drivetrain affects maneuverability, complexity, and how you write control code. Most FRC robots use differential or swerve drive.

### Differential Drive (Tank/Arcade/Curvature)

The simplest and most robust drivetrain — two independently powered sides. Cannot strafe (move sideways). Controlled with three modes:
- **Arcade**: One axis for forward/back, one for rotation. Most intuitive for operators.
- **Tank**: Left stick → left wheels, right stick → right wheels. More precise but harder for new drivers.
- **Curvature**: Like arcade, but maintains a constant radius curve at speed. Better for high-speed driving.

```java
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

DifferentialDrive drive = new DifferentialDrive(leftMotor, rightMotor);

// Arcade drive — inputs: -1.0 to 1.0. squareInputs=true by default for finer low-speed control.
// Squaring: input is squared (preserving sign) — gives more precision near zero, same max.
drive.arcadeDrive(speed, rotation);            // squareInputs = true (default)
drive.arcadeDrive(speed, rotation, false);     // false = linear input (full precision throughout)

// Tank drive — each side is controlled independently.
drive.tankDrive(leftSpeed, rightSpeed);

// Curvature drive — speed and curvature (1/radius) as inputs.
// turnInPlace: when speed is near zero, allows spinning in place (fallback behavior).
drive.curvatureDrive(speed, rotation, turnInPlace);

drive.stopMotor();  // Zeros all outputs immediately
drive.feed();       // Reset motor safety watchdog without setting output — call if managing motors manually
```

### Mecanum Drive

Mecanum wheels have angled rollers that let the robot strafe in any direction without rotating. Trade-off: less traction and pushing power than standard wheels. Good for mid-field tasks where lateral movement is needed but swerve complexity isn't justified.

```java
import edu.wpi.first.wpilibj.drive.MecanumDrive;

// Motor order is specific: front-left, rear-left, front-right, rear-right
MecanumDrive mecanum = new MecanumDrive(frontLeft, rearLeft, frontRight, rearRight);

// Robot-relative: moves relative to the robot's current facing direction.
mecanum.driveCartesian(xSpeed, ySpeed, zRotation);
// Field-relative: pass gyro angle so "forward" always means field-forward.
mecanum.driveCartesian(xSpeed, ySpeed, zRotation, gyroAngle);
mecanum.drivePolar(magnitude, angle, zRotation);  // Polar (magnitude + direction in degrees)
```

### Swerve Drive (advanced — see SwerveModuleState, ChassisSpeeds)

Swerve is the highest-performance drivetrain in FRC. Each module has two motors: one for **drive** (speed) and one for **steer** (direction). All four wheels can be pointed and driven independently, giving full holonomic movement (strafe + rotate simultaneously) with better traction than mecanum. Tradeoff: complex to implement and tune.

```java
import edu.wpi.first.math.geometry.*;
import edu.wpi.first.math.kinematics.*;

// Kinematics describes the physical layout of your modules relative to robot center.
// Positive X = front of robot; Positive Y = left side of robot.
SwerveDriveKinematics kinematics = new SwerveDriveKinematics(
    new Translation2d( 0.381,  0.381),  // front-left  (meters from center)
    new Translation2d( 0.381, -0.381),  // front-right
    new Translation2d(-0.381,  0.381),  // rear-left
    new Translation2d(-0.381, -0.381)   // rear-right
);

// ChassisSpeeds describes what you WANT the robot to do:
// vx = forward m/s, vy = strafe m/s (left positive), omega = rotation rad/s
ChassisSpeeds speeds = new ChassisSpeeds(vxMetersPerSec, vyMetersPerSec, omegaRadPerSec);

// Field-oriented: converts field-relative driver inputs to robot-relative speeds.
// Without this, "push left stick up" means "drive the direction the robot is facing",
// not "drive toward the far wall", which gets confusing when the robot is rotated.
ChassisSpeeds fieldRelative = ChassisSpeeds.fromFieldRelativeSpeeds(
    vx, vy, omega, gyro.getRotation2d()
);

// Kinematics converts ChassisSpeeds into four individual module states.
SwerveModuleState[] states = kinematics.toSwerveModuleStates(speeds);
// Desaturate: scale down all modules proportionally if any exceed the max speed.
SwerveDriveKinematics.desaturateWheelSpeeds(states, kMaxSpeedMetersPerSec);

// Each SwerveModule applies the state to its drive and steer motors.
// states[0] = front-left, states[1] = front-right, etc. (matches kinematics constructor order)
frontLeft.setDesiredState(states[0]);

// SwerveModuleState holds a speed and an angle. Always optimize to avoid unnecessary 180° turns.
SwerveModuleState state = new SwerveModuleState(speedMetersPerSec, Rotation2d.fromDegrees(angle));
state = SwerveModuleState.optimize(state, currentAngle);  // Flip speed + angle if it saves rotation
```

### Odometry (tracking robot position on field)

Odometry estimates the robot's position by integrating wheel encoder and gyro data over time. It drifts (errors compound), so it should be fused with vision for long-term accuracy. Always reset odometry when auto starts, because the starting position is known.

```java
import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.math.geometry.*;

DifferentialDriveOdometry odometry = new DifferentialDriveOdometry(
    gyro.getRotation2d(),      // Current heading
    leftEncoderMeters,          // Left encoder distance since last reset
    rightEncoderMeters,         // Right encoder distance since last reset
    new Pose2d(0, 0, new Rotation2d())  // Initial pose (set to match physical start position)
);

// Call every loop (in subsystem periodic) to keep position estimate current:
odometry.update(gyro.getRotation2d(), leftEncoderMeters, rightEncoderMeters);

Pose2d pose     = odometry.getPoseMeters();       // Current estimated position
double x        = pose.getX();                    // Meters from starting X (field blue origin)
double y        = pose.getY();                    // Meters from starting Y
double heading  = pose.getRotation().getDegrees(); // Current heading in degrees

// Swerve odometry (uses SwerveModulePosition[] instead of left/right distances):
SwerveDriveOdometry swerveOdometry = new SwerveDriveOdometry(
    kinematics, gyro.getRotation2d(), modulePositions
);
swerveOdometry.update(gyro.getRotation2d(), modulePositions);
```

---

## 11. PID Control

PID (Proportional-Integral-Derivative) is a feedback control algorithm that continuously adjusts a motor's output to minimize the error between a measured state (position, velocity) and a desired setpoint. It's the core of almost all precise motion in FRC.

**What each term does:**
- **P (Proportional):** Output = kP × error. The larger the error, the harder it pushes. Too high: oscillates. Too low: sluggish or doesn't reach setpoint.
- **I (Integral):** Output += kI × (accumulated error over time). Eliminates steady-state error (e.g., when gravity prevents full correction). Use very small values — it winds up and causes overshoots easily.
- **D (Derivative):** Output = kD × (rate of change of error). Dampens oscillation by reacting to how fast the error is changing. Too high: amplifies noise.

### WPILib PIDController (runs in robot code, ~20 ms loop)

The WPILib PIDController runs entirely in your robot code at 50 Hz (20 ms loop). This is slower than onboard motor controller PID (1 kHz) but gives you full flexibility — you can easily add feedforward, change setpoints, or integrate with vision.

```java
import edu.wpi.first.math.controller.PIDController;

PIDController pid = new PIDController(kP, kI, kD);
// Tolerance: defines what "at setpoint" means for atSetpoint() to return true.
// Use positional tolerance for position control, velocity tolerance for velocity control.
pid.setTolerance(0.05);             // Within 5 cm = "at setpoint"
pid.setIntegratorRange(-0.3, 0.3);  // Clamp integral term to prevent windup

// In periodic/execute — call every loop with current measurement and desired setpoint.
// Returns a signed output value: positive = push toward setpoint.
double output = pid.calculate(measurement, setpoint);
motor.set(output);

// Check if at goal (uses the tolerance set above):
if (pid.atSetpoint()) { ... }

// Reset clears integral accumulator and derivative state.
// Call when disabling, switching modes, or changing setpoints significantly.
pid.reset();
```

### ProfiledPIDController (with motion profiling — smoother motion)

A ProfiledPIDController generates a **trapezoidal motion profile** — instead of trying to jump directly to the setpoint, it accelerates to a max velocity then decelerates. This eliminates large initial error spikes and produces smoother, more predictable motion. Essential for arms and elevators.

```java
import edu.wpi.first.math.controller.ProfiledPIDController;
import edu.wpi.first.math.trajectory.TrapezoidProfile;

// Constraints define the maximum velocity and acceleration of the profile.
// These should match your mechanism's physical limits — too high and the profile is unreachable.
TrapezoidProfile.Constraints constraints =
    new TrapezoidProfile.Constraints(maxVelocity, maxAcceleration);

ProfiledPIDController ppid = new ProfiledPIDController(kP, kI, kD, constraints);
ppid.setGoal(targetPosition);   // or setGoal(new TrapezoidProfile.State(pos, vel))
// The controller internally tracks a "current profile state" that smoothly approaches the goal.
double output = ppid.calculate(currentPosition);
```

### Feedforward (combine with PID for better performance)

Feedforward is **open-loop** — it predicts the output needed to achieve a setpoint based on a model of the mechanism, without waiting for error. Adding feedforward dramatically reduces the work the PID has to do, resulting in faster response and less oscillation. Use SysId to characterize your mechanism and get accurate constants.

```java
import edu.wpi.first.math.controller.SimpleMotorFeedforward;
import edu.wpi.first.math.controller.ArmFeedforward;
import edu.wpi.first.math.controller.ElevatorFeedforward;

// SimpleMotorFeedforward: output = kS * sign(v) + kV * v + kA * a
// kS: static friction (minimum output to overcome stiction)
// kV: velocity constant (volts per unit/sec — characterizes motor + gearing)
// kA: acceleration constant (volts per unit/sec² — usually small, often 0)
SimpleMotorFeedforward ff = new SimpleMotorFeedforward(kS, kV, kA);
double ffOutput  = ff.calculate(velocitySetpoint);           // Steady-state (a = 0)
double ffOutput2 = ff.calculate(velocitySetpoint, accel);    // With known acceleration

// ArmFeedforward: adds a cosine gravity term (more voltage needed when arm is horizontal,
// less when vertical). Angle in radians from horizontal.
// kG: gravity constant (volts needed to hold arm horizontal)
ArmFeedforward armFF = new ArmFeedforward(kS, kG, kV, kA);
double armFFOut = armFF.calculate(angleRadians, velocitySetpoint);

// ElevatorFeedforward: adds a constant gravity term (always fighting gravity equally).
// kG: volts needed to hold elevator stationary against gravity.
ElevatorFeedforward elevFF = new ElevatorFeedforward(kS, kG, kV, kA);
double elevOut = elevFF.calculate(velocitySetpoint);

// Best practice — combine PID + FF:
// FF provides the "expected" output; PID corrects for any remaining error.
double output = pid.calculate(measurement, setpoint) + ff.calculate(setpoint);
```

### SysId (WPILib system identification — how to get kS, kV, kA, kP)

SysId runs automated voltage-ramp routines on your mechanism and logs data. You then analyze the logs in the WPILib SysId analysis tool to extract physically accurate feedforward and PID constants. This is far more reliable than manual tuning.

```java
// SysId runs special routines that apply voltage ramps and logs data.
// Then you analyze in the WPILib SysId tool to get feedforward constants.
// Minimal setup in your subsystem:

import edu.wpi.first.wpilibj2.command.sysid.SysIdRoutine;
import edu.wpi.first.units.*;

SysIdRoutine sysIdRoutine = new SysIdRoutine(
    new SysIdRoutine.Config(),  // Default: 1 V/s ramp rate, 7 V max, 10 s timeout
    new SysIdRoutine.Mechanism(
        // Drive: apply specified voltage to mechanism
        (voltage) -> motor.setVoltage(voltage.in(Units.Volts)),
        // Log: record mechanism state each loop (voltage, position, velocity)
        log -> {
            log.motor("drive-left")
               .voltage(Units.Volts.of(motor.get() * RobotController.getBatteryVoltage()))
               .linearPosition(Units.Meters.of(encoder.getDistance()))
               .linearVelocity(Units.MetersPerSecond.of(encoder.getRate()));
        },
        this  // Reference to this subsystem (for requirements)
    )
);

// In RobotContainer — bind to buttons to run the four characterization routines:
// Quasistatic Forward, Quasistatic Backward, Dynamic Forward, Dynamic Backward
// sysIdRoutine.quasistatic(SysIdRoutine.Direction.kForward)
// sysIdRoutine.dynamic(SysIdRoutine.Direction.kForward)
```

---

## 12. PathPlanner & Autonomous

Autonomous path following involves commanding the robot to follow a pre-planned path on the field based on its odometry/pose. PathPlanner is the community standard because it provides a GUI path editor, trajectory generation, and tight WPILib integration.

### PathPlanner (most popular FRC path-following library)

PathPlanner paths are Bezier curves drawn in a GUI on a field image. They're saved as JSON files in `src/main/deploy/pathplanner/` and deployed to the RoboRIO. The library generates time-parameterized trajectories from these paths and uses a holonomic PID controller to follow them.

```java
// build.gradle dependency:
// implementation "com.pathplanner.lib:pathplannerlib:YYYY.X.X"

import com.pathplanner.lib.auto.AutoBuilder;
import com.pathplanner.lib.util.HolonomicPathFollowerConfig;
import com.pathplanner.lib.util.PIDConstants;
import com.pathplanner.lib.util.ReplanningConfig;
import com.pathplanner.lib.commands.PathPlannerAuto;

// Configure AutoBuilder ONCE in DriveSubsystem constructor (swerve example).
// This tells PathPlanner how to read and control your specific robot.
AutoBuilder.configureHolonomic(
    this::getPose,                   // How to read current robot position (Pose2d supplier)
    this::resetOdometry,             // How to reset pose to a given Pose2d (for start of auto)
    this::getRobotRelativeSpeeds,    // Current ChassisSpeeds (robot-relative)
    this::driveRobotRelative,        // Apply ChassisSpeeds to drive the robot
    new HolonomicPathFollowerConfig(
        new PIDConstants(5.0, 0, 0),  // Translation PID (X and Y position correction)
        new PIDConstants(5.0, 0, 0),  // Rotation PID (heading correction)
        kMaxModuleSpeedMetersPerSec,  // Max speed a single module can reach
        kDriveBaseRadius,             // Meters from robot center to furthest module corner
        new ReplanningConfig()        // Whether to replan path if robot is off-course
    ),
    () -> {
        // Return true if robot should use the Red Alliance version of paths.
        // PathPlanner mirrors paths for red alliance automatically (field is symmetric).
        var alliance = DriverStation.getAlliance();
        return alliance.isPresent() && alliance.get() == DriverStation.Alliance.Red;
    },
    this  // Reference to drive subsystem (added as requirement to all path commands)
);

// Register named commands — these are event markers in the PathPlanner GUI.
// When the robot passes the marker on the path, the corresponding command is scheduled.
// Register BEFORE building the auto chooser.
NamedCommands.registerCommand("IntakeDown",  new IntakeDownCommand(m_intake));
NamedCommands.registerCommand("Shoot",       new ShootCommand(m_shooter));

// In RobotContainer — build a chooser from all .auto files in deploy/pathplanner/autos/
private final SendableChooser<Command> m_autoChooser = AutoBuilder.buildAutoChooser();

public Command getAutonomousCommand() {
    return m_autoChooser.getSelected();
    // OR load a specific auto by name (matches .auto file name):
    // return new PathPlannerAuto("MyAutoName");
}
```

### WPILib Trajectory Following (built-in, no external library)

WPILib includes RAMSETE trajectory following for differential drive robots. It's more manual than PathPlanner (no GUI editor, more code) but has no external dependency. Useful if you want to understand the underlying math or need a minimal setup.

```java
import edu.wpi.first.math.trajectory.*;
import edu.wpi.first.math.controller.*;
import edu.wpi.first.wpilibj2.command.RamseteCommand;

// Generate trajectory programmatically with start pose, interior waypoints, and end pose.
TrajectoryConfig config = new TrajectoryConfig(
    maxVelocityMetersPerSec,
    maxAccelMetersPerSecSq
).setKinematics(m_drive.getKinematics());  // Kinematics enforces wheel speed constraints

Trajectory trajectory = TrajectoryGenerator.generateTrajectory(
    new Pose2d(0, 0, new Rotation2d(0)),                              // Start pose
    List.of(new Translation2d(1, 0), new Translation2d(2, 1)),       // Interior waypoints
    new Pose2d(3, 0, new Rotation2d(0)),                              // End pose
    config
);

// RAMSETE is a nonlinear feedback controller designed for differential drive path following.
// kRamseteB (typically 2.0) and kRamseteZeta (typically 0.7) are tuning parameters.
RamseteCommand ramseteCmd = new RamseteCommand(
    trajectory,
    m_drive::getPose,
    new RamseteController(kRamseteB, kRamseteZeta),
    new SimpleMotorFeedforward(kS, kV, kA),
    m_drive.getKinematics(),
    m_drive::getWheelSpeeds,
    new PIDController(kPDriveVel, 0, 0),  // Left wheel velocity PID
    new PIDController(kPDriveVel, 0, 0),  // Right wheel velocity PID
    m_drive::tankDriveVolts,
    m_drive
);

return ramseteCmd.andThen(() -> m_drive.tankDriveVolts(0, 0));  // Stop when done
```

### Auto Chooser (Sendable)

SendableChooser lets operators select the auto routine from the Driver Station dashboard before the match. Options are displayed as a dropdown in Shuffleboard or SmartDashboard.

```java
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

SendableChooser<Command> chooser = new SendableChooser<>();
chooser.setDefaultOption("Do Nothing", new InstantCommand());       // Default if nothing selected
chooser.addOption("Drive Forward", new DriveForwardCommand(m_drive));
chooser.addOption("Two Piece",     new PathPlannerAuto("TwoPiece"));
SmartDashboard.putData("Auto Chooser", chooser);  // Publish to dashboard

// In autonomousInit — fetch and run whatever was selected:
Command auto = chooser.getSelected();
if (auto != null) auto.schedule();
```

---

## 13. SmartDashboard & Shuffleboard

> **2026 deprecation:** Both `SmartDashboard` and `Shuffleboard` are **deprecated for removal in 2027** due to lack of active maintainers. For new projects, use **Elastic** (the new default WPILib dashboard, replaces Shuffleboard) or **AdvantageScope** (powerful log-based visualization). SmartDashboard and Shuffleboard still work in 2026 and the APIs below remain valid — just expect them to be gone next year.
>
> Recommended replacements:
> - **Elastic** — drag-and-drop dashboard, bundled with WPILib 2026, connects over NetworkTables
> - **AdvantageScope** — replay `.wpilog` logs, plot signals, view field animation

Both tools display robot data on the Driver Station laptop. The difference is in how much control you have over the layout.

**SmartDashboard** is simple key-value logging — you call `putNumber()` and it shows up on the dashboard automatically. Use it for quick debugging and tuning during development.

**Shuffleboard** gives you full layout control — you can arrange widgets, set sizes, choose widget types (graph, dial, camera feed), and create tabs. Use it for competition-ready driver displays.

### SmartDashboard (simple key-value)
```java
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// Put values — call in periodic() so they update every loop.
// These appear as labeled boxes in SmartDashboard's auto layout.
SmartDashboard.putNumber("Shooter RPM",   m_shooter.getRPM());
SmartDashboard.putBoolean("Has Note",     m_intake.hasNote());
SmartDashboard.putString("Auto Mode",     m_auto.getName());

// Put a Sendable — WPILib knows how to display these objects richly.
// PIDController: shows P/I/D gains as editable fields; great for live tuning.
SmartDashboard.putData("Drive PID",       m_drivePID);
SmartDashboard.putData("Auto Chooser",    m_chooser);

// Get values — lets you read numbers the driver typed on the dashboard.
// Useful for tuning PID gains without redeploying code.
double p = SmartDashboard.getNumber("kP", 0.0);  // Second arg = default if not found
```

### Shuffleboard (layout control)
```java
import edu.wpi.first.wpilibj.shuffleboard.*;

// Create a tab in the Shuffleboard UI. Multiple subsystems can add to the same tab
// or different tabs for organization (e.g., "Drivetrain", "Shooter", "Debug").
ShuffleboardTab tab = Shuffleboard.getTab("Drivetrain");

// Add a Sendable with a specific widget type:
tab.add("Left Encoder", m_leftEncoder).withWidget(BuiltInWidgets.kEncoder);

// Add a number supplier with position and size in the grid:
tab.addNumber("Speed", () -> m_drive.getSpeed())
   .withPosition(0, 0)   // Column 0, Row 0 on the grid
   .withSize(2, 1);      // 2 wide, 1 tall (in grid units)

// Persistent entry — survives Driver Station restarts.
// Use this when you want to read a value the driver can change between matches.
NetworkTableEntry kpEntry = tab.add("kP", 0.1)
    .withWidget(BuiltInWidgets.kTextView)
    .getEntry();

// Read it back each loop in your subsystem's periodic():
double kp = kpEntry.getDouble(0.1);  // Default 0.1 if not set
```

---

## 14. NetworkTables

NetworkTables (NT4 in 2024+) is the real-time pub/sub communication layer that connects the robot to dashboards, co-processors (Raspberry Pi running PhotonVision), and other tools. SmartDashboard and Shuffleboard are built on top of it.

**How it works:** Devices **publish** values to named topics; other devices **subscribe** and receive updates automatically. The robot is the "server" — dashboards and co-processors are clients. All communication is over the field network (or USB for practice).

```java
import edu.wpi.first.networktables.*;

// Get the default instance (the robot's NT server connection)
NetworkTableInstance inst = NetworkTableInstance.getDefault();

// Publisher — robot sends data outward (to dashboard, co-processor, etc.)
NetworkTable table = inst.getTable("MyTable");  // "MyTable" is the namespace (like a folder)
DoublePublisher shooterRPM = table.getDoubleTopic("shooterRPM").publish();
shooterRPM.set(5000.0);  // Call each loop to keep value current

// Subscriber — robot reads data from a co-processor or dashboard.
// The default value (0.0) is returned until someone publishes to this topic.
DoubleSubscriber targetX = table.getDoubleTopic("targetX").subscribe(0.0);
double x = targetX.get();  // Call each loop to get latest value

// Limelight uses NT3-style raw entries (older protocol, but still works in NT4):
NetworkTable limelight = inst.getTable("limelight");
double tv = limelight.getEntry("tv").getDouble(0);  // 1.0 = target found, 0 = no target
double tx = limelight.getEntry("tx").getDouble(0);  // Horizontal angle to target (degrees)
limelight.getEntry("ledMode").setNumber(1);          // Set LED mode (see Limelight docs)

// Change listener — runs a callback when the value changes.
// Useful for reacting to co-processor events without polling each loop.
inst.addListener(
    table.getDoubleTopic("targetX").subscribe(0.0),
    EnumSet.of(NetworkTableEvent.Kind.kValueAll),  // Fires on every value update
    event -> System.out.println("New value: " + event.valueData.value.getDouble())
);
```

---

## 15. Vision (Limelight & PhotonVision)

Vision systems identify game pieces, scoring targets, and AprilTags on the field. The two dominant systems are **Limelight** (self-contained, runs on-camera) and **PhotonVision** (open-source software, runs on a co-processor like a Raspberry Pi or Orange Pi).

**Limelight** is simpler — it handles detection, AprilTag localization, and robot pose estimation on its own processor and publishes results to NetworkTables. No co-processor setup needed.

**PhotonVision** is more flexible — you configure cameras and pipelines in a web UI, and the library gives you structured Java objects (targets, poses) rather than raw NT values.

### Limelight (simplest setup — reads via NetworkTables)
```java
NetworkTable limelight = NetworkTableInstance.getDefault().getTable("limelight");

// Core targeting values (published every frame by Limelight's processor):
double tv  = limelight.getEntry("tv").getDouble(0);  // 1.0 = valid target found, 0 = no target
double tx  = limelight.getEntry("tx").getDouble(0);  // Horizontal offset from crosshair (degrees, + right)
double ty  = limelight.getEntry("ty").getDouble(0);  // Vertical offset from crosshair (degrees, + up)
double ta  = limelight.getEntry("ta").getDouble(0);  // Target area as % of image (0–100)
double tid = limelight.getEntry("tid").getDouble(-1); // Detected AprilTag ID (-1 = none detected)

// MegaTag2: Limelight 3+ can localize the robot on the field using multiple AprilTags.
// Returns a 7-element array: [x, y, z, roll, pitch, yaw, latency_ms]
// botpose_wpiblue uses blue alliance origin (matches WPILib field coordinates).
double[] botpose = limelight.getEntry("botpose_wpiblue").getDoubleArray(new double[7]);
if (botpose.length >= 6) {
    Pose2d visionPose = new Pose2d(botpose[0], botpose[1],
                                   Rotation2d.fromDegrees(botpose[5]));
    // Compensate for network + processing latency when fusing with odometry:
    double latencySeconds = botpose[6] / 1000.0;
    m_poseEstimator.addVisionMeasurement(visionPose,
        Timer.getFPGATimestamp() - latencySeconds);
}

// LED and pipeline control — sent TO Limelight (robot writes these):
limelight.getEntry("ledMode").setNumber(0);    // 0 = pipeline controls LEDs
limelight.getEntry("ledMode").setNumber(1);    // 1 = force off
limelight.getEntry("ledMode").setNumber(2);    // 2 = blink
limelight.getEntry("ledMode").setNumber(3);    // 3 = force on
limelight.getEntry("pipeline").setNumber(0);   // Switch to pipeline 0 (e.g., AprilTag pipeline)
limelight.getEntry("camMode").setNumber(0);    // 0 = vision processing mode
limelight.getEntry("camMode").setNumber(1);    // 1 = driver camera mode (increased exposure)
```

### PhotonVision (more flexible, runs on co-processor)

PhotonVision gives you strongly typed Java objects rather than raw NT doubles. It supports multi-target pose estimation (PnP) which is significantly more accurate than single-target range estimation.

```java
import org.photonvision.*;
import org.photonvision.targeting.*;

PhotonCamera camera = new PhotonCamera("photonvision");  // Name set in PV web UI

// Get latest detection result (non-blocking — returns last frame's data)
PhotonPipelineResult result = camera.getLatestResult();

if (result.hasTargets()) {
    // getBestTarget() returns the target with the highest confidence (lowest ambiguity for PnP)
    PhotonTrackedTarget target = result.getBestTarget();
    double yaw    = target.getYaw();           // Degrees, + = right of camera center
    double pitch  = target.getPitch();          // Degrees, + = above camera center
    double area   = target.getArea();           // % of image (like Limelight ta)
    int    id     = target.getFiducialId();     // AprilTag ID (-1 if not an AprilTag)

    // 3D transform from camera to target (requires calibrated camera + known tag size)
    Transform3d camToTarget = target.getBestCameraToTarget();
}

// PhotonPoseEstimator: computes full robot pose using AprilTag field layout.
// MULTI_TAG_PNP: uses all visible tags for a single accurate 3D pose (most accurate).
// Requires camera calibration (run in PhotonVision web UI using a chessboard).
PhotonPoseEstimator poseEstimator = new PhotonPoseEstimator(
    AprilTagFieldLayout.loadFromResource(AprilTagFields.k2024Crescendo.m_resourceFile),
    PoseStrategy.MULTI_TAG_PNP_ON_COPROCESSOR,
    camera,
    robotToCameraTransform  // Transform3d: where is the camera relative to robot center?
);

// Call in periodic — returns empty Optional if no tags visible
Optional<EstimatedRobotPose> estPose = poseEstimator.update();
estPose.ifPresent(est -> {
    m_poseEstimator.addVisionMeasurement(
        est.estimatedPose.toPose2d(),
        est.timestampSeconds  // Already compensated for latency by PhotonVision
    );
});
```

### SwerveDrivePoseEstimator (fuses odometry + vision)

The pose estimator uses a **Kalman filter** to fuse wheel odometry (fast, low-latency, but drifts) with vision measurements (slower, noisy, but absolute). Standard deviations express your confidence: lower = trust more. Well-tuned standard deviations give the most accurate pose.

```java
import edu.wpi.first.math.estimator.SwerveDrivePoseEstimator;

SwerveDrivePoseEstimator poseEstimator = new SwerveDrivePoseEstimator(
    kinematics,
    gyro.getRotation2d(),
    modulePositions,
    new Pose2d(),  // Initial pose (usually set from auto start pose)
    // Odometry standard deviations: [x_meters, y_meters, theta_radians]
    // These should be small — wheel odometry is quite accurate short-term.
    VecBuilder.fill(0.05, 0.05, Units.degreesToRadians(5)),
    // Vision standard deviations: larger = trust vision less.
    // Increase if camera is mounted poorly or tags are far away.
    VecBuilder.fill(0.5,  0.5,  Units.degreesToRadians(30))
);

// Call every loop in subsystem periodic():
poseEstimator.update(gyro.getRotation2d(), modulePositions);

// When a vision measurement arrives (asynchronous — call whenever new data is ready):
poseEstimator.addVisionMeasurement(visionPose, timestampSeconds);
// Or with per-measurement standard deviations (scale with distance to tags, number of tags seen):
poseEstimator.addVisionMeasurement(visionPose, timestamp,
    VecBuilder.fill(0.3, 0.3, Units.degreesToRadians(15)));
```

---

## 16. Pneumatics

Pneumatics use compressed air to actuate cylinders (pistons). Air is stored in a tank and regulated to ~60 PSI operating pressure. The compressor fills the tank automatically. The Pneumatics Control Module (PCM) or Pneumatics Hub (PH) controls solenoid valves that direct air into cylinders.

**Single-acting solenoid:** One coil controls airflow in one direction; a spring returns it. Simpler but only holds one end position firmly.

**Double-acting solenoid:** Two coils — one for extend, one for retract. Holds its position with air pressure (no spring). More reliable for mechanisms that must stay in position under load (kOff = no change in position).

### CTRE Pneumatics Control Module (PCM)
```java
import edu.wpi.first.wpilibj.PneumaticsModuleType;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Compressor;

// Compressor — auto-start by default.
// Digital mode: uses a pressure switch (binary on/off threshold).
// Analog mode (PH only): uses a pressure sensor for precise range control.
Compressor compressor = new Compressor(0, PneumaticsModuleType.CTREPCM);  // CAN ID 0
compressor.enableDigital();    // Auto-manage: runs until pressure switch opens
compressor.disable();          // Stop compressor manually (e.g., in teleop for match safety)

// Single-acting solenoid — spring returns when set to false.
// Channel number corresponds to the solenoid port on the PCM (0–7).
Solenoid single = new Solenoid(PneumaticsModuleType.CTREPCM, 0);
single.set(true);    // Energize — extend cylinder (overcome spring)
single.set(false);   // De-energize — spring retracts cylinder
single.toggle();     // Flip current state

// Double-acting solenoid — two channels, two coils.
// kForward: extend (channel 0 energized). kReverse: retract (channel 1 energized).
// kOff: neither coil energized — cylinder stays at current position (air pressure holds it).
DoubleSolenoid doubleSol = new DoubleSolenoid(
    PneumaticsModuleType.CTREPCM, 0, 1);  // forward channel=0, reverse channel=1
doubleSol.set(DoubleSolenoid.Value.kForward);
doubleSol.set(DoubleSolenoid.Value.kReverse);
doubleSol.set(DoubleSolenoid.Value.kOff);     // Hold current position
doubleSol.toggle();  // kForward ↔ kReverse (skips kOff)
```

### REV Pneumatics Hub (PH)
```java
// Same solenoid API — only the module type changes.
// The PH supports analog pressure sensing (enableAnalog) for precise pressure control.
Solenoid single = new Solenoid(PneumaticsModuleType.REVPH, 0);
Compressor comp  = new Compressor(1, PneumaticsModuleType.REVPH);  // CAN ID 1
comp.enableAnalog(60, 120);  // Run compressor to keep pressure between 60 and 120 PSI
```

---

## 17. CAN Bus & Power Distribution

### CAN Bus Overview

CAN (Controller Area Network) is a two-wire differential bus that connects all smart devices on the robot: motor controllers, IMUs, PDH, and more. Each device needs a **unique CAN ID** (0–62 on the RoboRIO bus). Devices communicate at 1 Mbps; too many devices or too much traffic can cause CAN bus utilization warnings (keep under ~90%).

**Wiring:** CAN uses a daisy-chain topology with 120Ω termination resistors at both ends of the chain. Stub connections and Y-splitters increase signal reflections and can cause drop-outs.

### Power Distribution Panel / Hub
```java
import edu.wpi.first.wpilibj.PowerDistribution;

// REV Power Distribution Hub (PDH) — 20 high-current channels
PowerDistribution pdh = new PowerDistribution(1, PowerDistribution.ModuleType.kRev);
// CTRE Power Distribution Panel (PDP) — older, 16 channels
PowerDistribution pdp = new PowerDistribution(0, PowerDistribution.ModuleType.kCTRE);

double totalCurrent = pdh.getTotalCurrent();    // Total amps drawn by all channels
double voltage      = pdh.getVoltage();          // Battery voltage at PDH terminals
double ch0Current   = pdh.getCurrent(0);         // Current on channel 0 (amps)
double temp         = pdh.getTemperature();      // Internal temperature in Celsius
// Use these in periodic() to log power data and detect hardware issues
```

### RoboRIO & CAN Bus Diagnostics
```java
import edu.wpi.first.wpilibj.RobotController;

double batteryVoltage = RobotController.getBatteryVoltage();  // Same as PDH.getVoltage()
// isBrownedOut: true if battery voltage dropped below ~6.3V and RoboRIO reduced power.
// Brownouts cause CAN devices to drop offline and motors to stop — very bad during a match.
boolean isBrownedOut  = RobotController.isBrownedOut();
// getFPGATime: microseconds since FPGA boot. Use for precise timestamping (e.g., vision latency).
double fpgaTime       = RobotController.getFPGATime() / 1e6;  // Convert to seconds

// CANivore (CTRE's USB-CAN adapter for Phoenix 6)
// Runs a separate isolated CAN bus at higher bandwidth than the RoboRIO's built-in CAN.
// Particularly useful on swerve robots with 8+ TalonFX controllers.
// 2025 (deprecated in 2026): String-based CANivore bus name
// TalonFX motor = new TalonFX(1, "canivore1");  // DEPRECATED — String constructor removed in 2027

// 2026+: Use CANBus object instead
import com.ctre.phoenix6.CANBus;
CANBus canivore = new CANBus("canivore1");  // "canivore1" is the name set in Phoenix Tuner X
TalonFX motor = new TalonFX(1, canivore);
Pigeon2 imu   = new Pigeon2(0, canivore);
```

---

## 18. Robot Simulation

WPILib's simulation framework lets you test robot code on your laptop without hardware. The simulation uses physics models (DC motor dynamics, kinematics) to produce realistic sensor readings in response to motor commands. This is invaluable for testing auto routines, PID tuning, and command logic without destroying hardware.

**How it works:** Your robot code runs normally. Motor controller outputs are intercepted by simulation classes that compute how the mechanism would respond physically. Simulated sensor readings are fed back into your code as if real hardware was attached.

```java
// In your Subsystem, add simulation counterparts:
import edu.wpi.first.wpilibj.simulation.*;
import edu.wpi.first.math.system.plant.*;

// DCMotor represents the motor's electrical characteristics (Kt, Kv, resistance, etc.)
// 2026: new motor types added: DCMotor.getKrakenX44(1) and DCMotor.getMinion(1)
DCMotor gearboxSim = DCMotor.getNEO(1);  // 1 NEO motor
// Other options: .getFalcon500(1), .getKrakenX60(1), .getKrakenX44(1), .getMinion(1), .getNeoVortex(1)

// FlywheelSim models a rotating flywheel (or any rotating mass).
// momentOfInertia in kg*m² — estimate from CAD or measure experimentally.
FlywheelSim flywheelSim = new FlywheelSim(
    gearboxSim,
    gearRatio,       // Motor-to-output gear ratio (e.g., 1.5 for 1.5:1 reduction)
    momentOfInertia  // kg*m² — resistance to changes in rotation
);

// ElevatorSim models a linear elevator with gravity.
// Gravity simulation means output won't hold position without a control loop.
ElevatorSim elevSim = new ElevatorSim(
    gearboxSim, gearRatio, massKg,
    drumRadiusMeters,   // Radius of spool that winds the cable
    minHeightMeters,    // Lower hard stop
    maxHeightMeters,    // Upper hard stop
    simulateGravity,    // true = include gravity force
    startingHeightMeters
);

// simulationPeriodic() is automatically called by TimedRobot when running in simulation.
// It runs alongside periodic() every 20 ms loop.
@Override
public void simulationPeriodic() {
    // Step 1: Set motor input voltage into the physics model.
    flywheelSim.setInput(m_motor.get() * RobotController.getBatteryVoltage());
    // Step 2: Advance the simulation by one time step.
    flywheelSim.update(0.020);  // 20 ms
    // Step 3: Write simulated outputs back to your encoder sim object,
    //         so your real sensor-reading code sees realistic values.
    m_encoderSim.setRate(flywheelSim.getAngularVelocityRPM() / 60.0);
}
```

### Simulation in VS Code
- **Run simulation:** `./gradlew simulateJava` (or use the WPILib palette: "Simulate Robot Code")
- **Driver Station:** Connect to `localhost` (127.0.0.1) instead of 10.TE.AM.2
- **Glass:** WPILib's visualization tool — shows field view (robot position), mechanism diagrams, signal plots
- **AdvantageScope:** More powerful logging/visualization alternative (supports `.wpilog` replay)
- **No hardware needed:** Test full auto routines, verify path following, and tune PID gains before the first robot run

---

## 19. Vendor Libraries Cheatsheet

Vendor libraries add support for hardware and tools not included in WPILib. Each library ships as a Maven artifact + a `.json` vendordep file that Gradle uses to download it.

| Library | vendordep URL / file | Purpose |
|---|---|---|
| CTRE Phoenix 6 | https://maven.ctr-electronics.com/release/com/ctre/phoenix6/latest/Phoenix6-frc2026-latest.json | TalonFX, Pigeon 2, CANcoder (modern API) |
| CTRE Phoenix 5 | https://maven.ctr-electronics.com/release/com/ctre/phoenix/Phoenix5-frc2026-latest.json | TalonSRX, VictorSPX, Pigeon 1 (legacy) |
| REV Robotics | https://software-metadata.revrobotics.com/REVLib-2026.json | SparkMAX, SparkFlex, Color Sensor, Through-Bore Encoder |
| NavX / StudicaLib | https://dev.studica.com/maven/release/2026/json/Studica-2026.0.0.json | NavX, NavX2, NavX3-CAN gyro — **package changed to `com.studica.frc`** |
| PathPlanner | https://3015rangerrobotics.github.io/pathplannerlib/PathplannerLib.json | GUI path editor + trajectory following |
| PhotonVision | https://maven.photonvision.org/repository/internal/org/photonvision/photonlib-json/1.0/photonlib-json-1.0.json | Vision processing + pose estimation |
| Choreo | Comes with WPILib 2025+ | Alternative path planner (trajectory-first design) |

**When to use Phoenix 6 vs Phoenix 5:**
- Use Phoenix 6 for any new TalonFX (Falcon 500, Kraken X60, or Kraken X44) or Pigeon 2.
- Use Phoenix 5 only if you have legacy TalonSRX, VictorSPX, or Pigeon 1 hardware — do not mix APIs on the same device.
- Phoenix 6 requires Phoenix Tuner X (not Phoenix Tuner) for configuration and firmware updates.
- **2026:** The `new TalonFX(id, "canivore")` String-based constructor is deprecated. Use `new TalonFX(id, new CANBus("canivore"))` instead (see Section 17).

**2026 NavX migration note:** The NavX vendordep changed publishers (Kauai Labs → Studica Robotics). Remove the old `Studica` vendordep and install `StudicaLib`. Update imports from `com.kauailabs.navx.frc.AHRS` → `com.studica.frc.AHRS`. Both cannot be installed simultaneously.

**Installing vendordep in VS Code:**
`Ctrl+Shift+P` → `WPILib: Manage Vendor Libraries` → `Install new library (online)` → paste URL

---

## 20. Common Gotchas & Best Practices

### Motor Safety Timeout

WPILib has a built-in motor safety system that **stops all motors** if they aren't given a new command within ~100 ms. This prevents runaway motors if your code crashes or hangs. `DifferentialDrive` calls `feed()` automatically when you call `arcadeDrive()`. If you bypass the drive class and control motors directly, you must disable safety or feed manually.

```java
// Disable safety on a motor you're controlling with manual periodic calls:
motor.setSafetyEnabled(false);
// OR, if you want safety enabled, call this every loop to reset the watchdog:
motor.feed();
```

### Inversion & Direction

The most common first-day bug. Always verify that positive output = forward/up/intended direction for every motor before running commands. Right-side drivetrain motors face opposite directions physically, so they need inversion.

```java
// Always double-check: positive input should mean forward/up/intake-in.
// Right side of differential drive usually needs inversion because the motors face opposite ways:
rightMotor.setInverted(true);
// CTRE Phoenix 6: use InvertedValue enum (not a boolean):
config.MotorOutput.Inverted = InvertedValue.Clockwise_Positive;
// REV SparkMAX: simple boolean (true = reverse positive direction):
motor.setInverted(true);
```

### Alliance-Relative Coordinates

Since 2023, WPILib uses a fixed field coordinate system with the **blue alliance wall at the origin**. This means Red Alliance robots start at the far end of the field. PathPlanner handles mirroring automatically, but if you hardcode poses, you need to flip them for Red.

```java
// Blue alliance origin: X increases toward Red alliance wall, Y increases to the left.
// For Red alliance, mirror X across the field length and flip heading 180°:
if (DriverStation.getAlliance().orElse(Alliance.Blue) == Alliance.Red) {
    pose = new Pose2d(fieldLengthMeters - pose.getX(), pose.getY(),
                     pose.getRotation().plus(Rotation2d.fromDegrees(180)));
}
// PathPlanner handles this automatically with the alliance flip lambda in AutoBuilder.configureHolonomic()
```

### `burnFlash()` on SparkMAX/SparkFlex

SparkMAX flash memory has a limited number of write cycles (approximately 10,000). Calling `burnFlash()` on every `robotInit()` will eventually wear out the memory. Call it only once after first configuration, or after intentional parameter changes — not every deploy.

```java
// Correct pattern: configure everything, then burn once in the constructor.
motor.restoreFactoryDefaults();  // Reset to known state
motor.setIdleMode(IdleMode.kBrake);
motor.setSmartCurrentLimit(40);
motor.burnFlash();  // Last line of constructor — saves config to flash permanently
// Do NOT call burnFlash() in robotInit() or periodic() — only in the constructor
```

### Avoiding Loop Overruns

The robot loop must finish within 20 ms. If it takes longer, the Scheduler skips that cycle and prints a "Loop time of 0.02s overrun" warning on the dashboard. Persistent overruns cause jerky motion and unreliable control.

```java
// Things that block or are slow — NEVER do these in periodic():
// - Thread.sleep()          — pauses the thread, blocks everything
// - File I/O                — disk reads are slow and unpredictable
// - Blocking CAN reads      — waiting in a tight loop for status frames
// - Creating new objects in hot paths — triggers garbage collection (GC pauses)

// Example of what NOT to do:
@Override
public void periodic() {
    Thread.sleep(10);                    // WRONG — blocks for 10 ms!
    new double[1000];                    // WRONG — unnecessary allocation
}

// If you see loop overrun warnings:
// 1. Check for blocking calls in periodic() methods
// 2. Use LoopOverrunNotifier or log Timer.getFPGATime() deltas to find the culprit
// 3. Move heavy calculations off the main thread (Notifier or separate thread with care)
```

### `addRequirements()` — Don't Forget This

Without `addRequirements()`, the Scheduler doesn't know your command uses a subsystem. Two commands can then run simultaneously and fight over the same hardware — causing unpredictable motion or damaged mechanisms.

```java
// ALWAYS call addRequirements() in the Command constructor.
// List every Subsystem this command directly controls.
public IntakeCommand(IntakeSubsystem intake) {
    m_intake = intake;
    addRequirements(m_intake);  // Without this: silent hardware conflicts!
    // If command uses multiple subsystems: addRequirements(m_intake, m_conveyor);
}
```

### DriverStation & FMS

The Field Management System (FMS) at competitions automatically enables/disables robots and sends match timing. Always test that your code respects FMS signals — especially `autonomousInit()` and `teleopInit()`.

```java
import edu.wpi.first.wpilibj.DriverStation;

boolean isAuto         = DriverStation.isAutonomous();
boolean isTeleop       = DriverStation.isTeleop();
boolean isEnabled      = DriverStation.isEnabled();
boolean isFMSAttached  = DriverStation.isFMSAttached();  // True at competition (not in practice)
double  matchTime      = DriverStation.getMatchTime();   // Seconds remaining in current period (-1 if unknown)

// Check alliance — returns Optional because alliance isn't known until DS connects.
Optional<Alliance> alliance = DriverStation.getAlliance();
alliance.ifPresent(a -> {
    if (a == DriverStation.Alliance.Red) { /* adjust paths, positions, etc. */ }
});
```

### Units Library (WPILib 2024+)

The Units library provides type-safe unit conversions, eliminating entire classes of bugs from mixing meters with inches or radians with degrees.

```java
import edu.wpi.first.units.*;
import static edu.wpi.first.units.Units.*;

// Create typed measurements — compile errors if you pass the wrong type.
Measure<Distance>               dist  = Meters.of(1.5);
Measure<Velocity<Distance>>     vel   = MetersPerSecond.of(3.0);
Measure<Angle>                  angle = Degrees.of(90);

// Convert between units — always explicit, no silent errors:
double meters   = dist.in(Meters);
double inches   = dist.in(Inches);
double radians  = angle.in(Radians);
// dist.in(Radians) would be a compile error — distances and angles are different types.
```

### Useful WPILib Utilities

```java
import edu.wpi.first.math.MathUtil;

MathUtil.clamp(value, min, max);                    // Clamp value to [min, max] range
MathUtil.applyDeadband(value, deadband);             // Zero inputs smaller than deadband, then rescale
MathUtil.inputModulus(value, -Math.PI, Math.PI);    // Wrap angle into a range (handles ±π wrap-around)
MathUtil.interpolate(startValue, endValue, t);       // Linear interpolation: t=0 → start, t=1 → end

// NEW in 2026: 2D circular deadband — treats the joystick as a unit circle.
// Inputs within the deadband RADIUS are zeroed together, avoiding the "plus-shaped" dead zone
// you'd get from applying 1D deadband separately to X and Y. Use for swerve field-oriented drive.
double leftX = controller.getLeftX();
double leftY = -controller.getLeftY();
double magnitude = Math.hypot(leftX, leftY);
double scaledMag = MathUtil.applyDeadband(magnitude, 0.1);
double scale = (magnitude > 1e-6) ? scaledMag / magnitude : 0.0;
double xDeadzoned = leftX * scale;
double yDeadzoned = leftY * scale;

// SlewRateLimiter: limits how fast a value can change (prevents jerk / mechanical shock).
// Useful for throttle inputs on drivetrains — avoids tipping or wheel slip on hard accelerations.
import edu.wpi.first.math.filter.SlewRateLimiter;
SlewRateLimiter limiter = new SlewRateLimiter(2.0);  // Max 2 units/sec change
double smoothed = limiter.calculate(rawInput);        // Call every loop — output ramps toward input

// Debouncer: requires a signal to be stable for a minimum time before passing it through.
// Eliminates false triggers from sensor noise or mechanical bounce on limit switches.
import edu.wpi.first.math.filter.Debouncer;
Debouncer debouncer = new Debouncer(0.1, Debouncer.DebounceType.kBoth);
// kBoth: debounce both rising and falling edges (most conservative)
// kRising: only debounce true → false transition
// kFalling: only debounce false → true transition
boolean stable = debouncer.calculate(sensor.get());  // Only true after 0.1s of stable true input
```

---

*Reference written for FRC 2026 season (WPILib 2026.2.1). WPILib and vendor library APIs change yearly — always check the [official docs](https://docs.wpilib.org) and changelogs before each season.*

**Key 2026 migration checklist (from 2025):**
- [ ] Re-import all vendor libraries (URLs changed — see Section 19)
- [ ] Update NavX import: `com.kauailabs.navx.frc.AHRS` → `com.studica.frc.AHRS`
- [ ] Replace `command.schedule()` calls → `CommandScheduler.getInstance().schedule(command)`
- [ ] Replace `new TalonFX(id, "canivore")` → `new TalonFX(id, new CANBus("canivore"))`
- [ ] Consider migrating from Shuffleboard/SmartDashboard to Elastic (both deprecated for 2027)
