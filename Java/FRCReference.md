# FRC Java / WPILib Quick Reference Guide

---

## Table of Contents
1. [Project Structure](#1-project-structure)
2. [Robot Base Classes](#2-robot-base-classes)
3. [Command-Based Programming](#3-command-based-programming)
4. [Subsystems](#4-subsystems)
5. [Commands](#5-commands)
6. [Triggers & Default Commands](#6-triggers--default-commands)
7. [Motor Controllers](#7-motor-controllers)
8. [Sensors](#8-sensors)
9. [Joysticks & Controllers](#9-joysticks--controllers)
10. [Drivetrain Types](#10-drivetrain-types)
11. [PID Control](#11-pid-control)
12. [PathPlanner & Autonomous](#12-pathplanner--autonomous)
13. [SmartDashboard & Shuffleboard](#13-smartdashboard--shuffleboard)
14. [NetworkTables](#14-networktables)
15. [Vision (Limelight & PhotonVision)](#15-vision-limelight--photonvision)
16. [Pneumatics](#16-pneumatics)
17. [CAN Bus & Power Distribution](#17-can-bus--power-distribution)
18. [Robot Simulation](#18-robot-simulation)
19. [Vendor Libraries Cheatsheet](#19-vendor-libraries-cheatsheet)
20. [Common Gotchas & Best Practices](#20-common-gotchas--best-practices)

---

## 1. Project Structure

A standard WPILib project generated by VS Code looks like this:

```
MyRobot/
├── src/main/java/frc/robot/
│   ├── Main.java               // Entry point — do NOT touch this
│   ├── Robot.java              // Top-level robot class (TimedRobot or CommandRobot)
│   ├── RobotContainer.java     // Wires subsystems + commands + button bindings
│   ├── Constants.java          // All magic numbers live here
│   ├── commands/               // One file per Command
│   └── subsystems/             // One file per Subsystem
├── src/main/deploy/            // Files deployed to RoboRIO (e.g., PathPlanner paths)
├── vendordeps/                 // JSON files for third-party libraries (CTRE, REV, etc.)
└── build.gradle                // Build config — add vendor deps here
```

**Constants.java pattern:**
```java
public final class Constants {
    // Nest constants in inner classes by subsystem to avoid name collisions
    public static final class DriveConstants {
        public static final int kFrontLeftMotorID = 1;
        public static final int kFrontRightMotorID = 2;
        public static final double kMaxSpeedMetersPerSecond = 4.5;
    }

    public static final class OperatorConstants {
        public static final int kDriverControllerPort = 0;
    }
}
```

---

## 2. Robot Base Classes

### TimedRobot (simplest, no command framework)

The robot's `robotPeriodic()` and mode-specific periodic methods are called every **20 ms** by the scheduler loop.

```java
public class Robot extends TimedRobot {

    @Override
    public void robotInit() {
        // Runs once when robot code starts (power on or code deploy)
    }

    @Override
    public void robotPeriodic() {
        // Runs every 20 ms regardless of mode — good for telemetry
        // If using Command-Based, this MUST call CommandScheduler.getInstance().run()
        CommandScheduler.getInstance().run();
    }

    @Override
    public void autonomousInit()    { /* runs once when auto starts */ }
    @Override
    public void autonomousPeriodic(){ /* runs every 20 ms in auto */ }

    @Override
    public void teleopInit()        { /* runs once when teleop starts */ }
    @Override
    public void teleopPeriodic()    { /* runs every 20 ms in teleop */ }

    @Override
    public void disabledInit()      { /* runs once when disabled */ }
    @Override
    public void disabledPeriodic()  { /* runs every 20 ms while disabled */ }

    @Override
    public void testInit()          { }
    @Override
    public void testPeriodic()      { }
}
```

**Key concepts:**
- All `*Periodic()` methods run on the **main robot thread** — never block with `Thread.sleep()`.
- The 20 ms loop period can be changed with `super.setPeriod(0.02)` in `robotInit()`.
- `TimedRobot` is perfectly fine for simple robots — you don't *have* to use Command-Based.

---

## 3. Command-Based Programming

Command-Based is WPILib's recommended framework. It separates *what the robot can do* (Subsystems) from *how it does it* (Commands).

### Core idea
```
Subsystem  — owns hardware, has actions (methods)
Command    — uses one or more Subsystems, has lifecycle methods (init/execute/end/isFinished)
Scheduler  — runs all active Commands every loop; handles conflicts via Requirements
```

### RobotContainer.java (the wiring hub)
```java
public class RobotContainer {
    // Subsystems
    private final DriveSubsystem m_drive = new DriveSubsystem();
    private final IntakeSubsystem m_intake = new IntakeSubsystem();

    // Controllers
    private final XboxController m_driverController =
        new XboxController(OperatorConstants.kDriverControllerPort);

    public RobotContainer() {
        configureBindings();

        // Set default command for drive subsystem (runs when no other command needs it)
        m_drive.setDefaultCommand(
            new ArcadeDriveCommand(m_drive,
                () -> -m_driverController.getLeftY(),   // throttle
                () ->  m_driverController.getRightX())  // turn
        );
    }

    private void configureBindings() {
        // Run intake while A button is held
        new JoystickButton(m_driverController, XboxController.Button.kA.value)
            .whileTrue(new IntakeCommand(m_intake));

        // Toggle arm on B button press
        new JoystickButton(m_driverController, XboxController.Button.kB.value)
            .toggleOnTrue(new ArmUpCommand(m_arm));
    }

    // Called by Robot.java to get the auto command
    public Command getAutonomousCommand() {
        return new ExampleAutoCommand(m_drive);
    }
}
```

---

## 4. Subsystems

A Subsystem owns hardware and exposes methods (not commands) to interact with it.

```java
import edu.wpi.first.wpilibj2.command.SubsystemBase;

public class DriveSubsystem extends SubsystemBase {

    private final WPI_TalonFX m_leftMotor  = new WPI_TalonFX(DriveConstants.kFrontLeftMotorID);
    private final WPI_TalonFX m_rightMotor = new WPI_TalonFX(DriveConstants.kFrontRightMotorID);
    private final DifferentialDrive m_drive;

    public DriveSubsystem() {
        m_rightMotor.setInverted(true);  // Right side usually needs inversion
        m_drive = new DifferentialDrive(m_leftMotor, m_rightMotor);
    }

    // Action method — called by Commands
    public void arcadeDrive(double speed, double rotation) {
        m_drive.arcadeDrive(speed, rotation);
    }

    public void stopDrive() {
        m_drive.stopMotor();
    }

    @Override
    public void periodic() {
        // Called every 20 ms by the scheduler; use for telemetry/sensor reads
        SmartDashboard.putNumber("Left Encoder", m_leftMotor.getSelectedSensorPosition());
    }
}
```

**Rules for Subsystems:**
- Never put game logic inside `periodic()` — that belongs in Commands.
- Hardware (motors, sensors) should be `private` fields — expose only methods.
- Each piece of hardware should belong to **exactly one** Subsystem.

---

## 5. Commands

Commands have four lifecycle methods:

```java
import edu.wpi.first.wpilibj2.command.Command;

public class IntakeCommand extends Command {

    private final IntakeSubsystem m_intake;

    public IntakeCommand(IntakeSubsystem intake) {
        m_intake = intake;
        addRequirements(intake);  // REQUIRED — tells scheduler this command uses intake
    }

    @Override
    public void initialize() {
        // Runs once when command first scheduled
        m_intake.setSpeed(0.8);
    }

    @Override
    public void execute() {
        // Runs every 20 ms while command is active
    }

    @Override
    public void end(boolean interrupted) {
        // Runs once when command ends (either normally or was interrupted)
        m_intake.stop();
    }

    @Override
    public boolean isFinished() {
        // Return true to end the command; false to keep running
        return false;  // false = run forever until interrupted
    }
}
```

### Inline Commands (lambda-based, no separate file needed)

```java
// RunCommand — runs execute() forever (isFinished always false)
new RunCommand(() -> m_intake.setSpeed(0.8), m_intake);

// InstantCommand — runs once then finishes immediately
new InstantCommand(() -> m_intake.stop(), m_intake);

// StartEndCommand — runs on init, stops on end
new StartEndCommand(
    () -> m_intake.setSpeed(0.8),  // initialize
    () -> m_intake.stop(),         // end
    m_intake
);

// FunctionalCommand — full control with lambdas
new FunctionalCommand(
    () -> m_intake.setSpeed(0.8),     // initialize
    () -> {},                          // execute
    interrupted -> m_intake.stop(),   // end
    () -> m_intake.isAtLimit(),       // isFinished
    m_intake
);
```

### Command Composition (chaining commands together)

```java
// Sequential: run commands one after another
new SequentialCommandGroup(
    new DriveForwardCommand(m_drive, 1.0),  // drives 1 meter
    new TurnCommand(m_drive, 90),           // turns 90 degrees
    new IntakeCommand(m_intake)             // then intakes
);

// Parallel: run commands at same time, end when ALL finish
new ParallelCommandGroup(
    new ArmUpCommand(m_arm),
    new ExtendWristCommand(m_wrist)
);

// Parallel race: run commands at same time, end when FIRST one finishes
new ParallelRaceGroup(
    new IntakeCommand(m_intake),
    new WaitCommand(2.0)    // intake for max 2 seconds
);

// Parallel deadline: end when a specific "deadline" command finishes
new ParallelDeadlineGroup(
    new WaitCommand(3.0),      // deadline
    new DriveForwardCommand(m_drive),
    new IntakeCommand(m_intake)
);

// Fluent chaining (same as above but cleaner syntax)
driveForward.andThen(turn).andThen(intake);
driveForward.alongWith(armUp);
driveForward.raceWith(new WaitCommand(5.0));
driveForward.withTimeout(5.0);   // shorthand for race with WaitCommand
```

---

## 6. Triggers & Default Commands

### Button Bindings
```java
JoystickButton btn = new JoystickButton(controller, XboxController.Button.kA.value);

btn.onTrue(command);          // Schedule when button pressed, doesn't cancel on release
btn.onFalse(command);         // Schedule when button released
btn.whileTrue(command);       // Schedule while held, cancel on release
btn.whileFalse(command);      // Schedule while not held
btn.toggleOnTrue(command);    // Toggle each press
btn.toggleOnFalse(command);
```

### Trigger from any boolean condition
```java
// Custom trigger — fires when intake sensor is triggered
Trigger intakeSensor = new Trigger(() -> m_intake.hasNote());
intakeSensor.onTrue(new RumbleCommand(m_controller));

// Trigger from SmartDashboard boolean
Trigger dashTrigger = new Trigger(
    NetworkButton.fromSmartDashboard("Enable Shooter")
);
```

### Default Commands
```java
// Runs when no other command requires this subsystem
m_drive.setDefaultCommand(
    new ArcadeDriveCommand(m_drive,
        () -> -m_driver.getLeftY(),
        () ->  m_driver.getRightX())
);
```

---

## 7. Motor Controllers

### CTRE TalonFX (Falcon 500 / Kraken X60)
```java
import com.ctre.phoenix6.hardware.TalonFX;
import com.ctre.phoenix6.controls.*;
import com.ctre.phoenix6.configs.*;

TalonFX motor = new TalonFX(1);  // CAN ID 1

// Basic output
motor.set(0.5);  // 50% duty cycle (-1.0 to 1.0)

// Configuration (Phoenix 6)
TalonFXConfiguration config = new TalonFXConfiguration();
config.MotorOutput.NeutralMode = NeutralModeValue.Brake;
config.MotorOutput.Inverted    = InvertedValue.Clockwise_Positive;
config.CurrentLimits.SupplyCurrentLimit        = 40;   // amps
config.CurrentLimits.SupplyCurrentLimitEnable  = true;
motor.getConfigurator().apply(config);

// Position control (Phoenix 6 control requests)
PositionVoltage posReq = new PositionVoltage(0).withSlot(0);
motor.setControl(posReq.withPosition(10.0));  // 10 rotations

// Velocity control
VelocityVoltage velReq = new VelocityVoltage(0).withSlot(0);
motor.setControl(velReq.withVelocity(50.0));  // 50 rotations/sec

// Follower
TalonFX follower = new TalonFX(2);
follower.setControl(new Follower(motor.getDeviceID(), true)); // true = oppose master

// Read position/velocity
double position = motor.getPosition().getValueAsDouble(); // rotations
double velocity = motor.getVelocity().getValueAsDouble(); // rotations/sec
```

### REV SparkMAX (NEO, NEO 550)
```java
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkBase.IdleMode;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkPIDController;

CANSparkMax motor = new CANSparkMax(1, CANSparkMax.MotorType.kBrushless);

// Configuration
motor.restoreFactoryDefaults();        // ALWAYS call first
motor.setIdleMode(IdleMode.kBrake);
motor.setInverted(false);
motor.setSmartCurrentLimit(40);        // amps
motor.burnFlash();                     // Save config to flash (call ONCE after configuring)

// Basic output
motor.set(0.5);

// Encoder
RelativeEncoder encoder = motor.getEncoder();
encoder.setPositionConversionFactor(/* meters per rotation */ 0.0508 * Math.PI / 6.75);
encoder.setVelocityConversionFactor(/* m/s per RPM */         0.0508 * Math.PI / 6.75 / 60.0);
double pos = encoder.getPosition(); // in converted units
double vel = encoder.getVelocity(); // in converted units

// Onboard PID (runs on SparkMAX itself at 1 kHz)
SparkPIDController pid = motor.getPIDController();
pid.setP(0.1);
pid.setI(0.0);
pid.setD(0.01);
pid.setFF(0.0);
pid.setReference(100, CANSparkMax.ControlType.kVelocity); // RPM
pid.setReference(10,  CANSparkMax.ControlType.kPosition); // rotations

// Follower
CANSparkMax follower = new CANSparkMax(2, CANSparkMax.MotorType.kBrushless);
follower.follow(motor, true);  // true = invert
```

### REV SparkFlex (NEO Vortex)
```java
// Almost identical to SparkMAX
import com.revrobotics.CANSparkFlex;
CANSparkFlex motor = new CANSparkFlex(1, CANSparkFlex.MotorType.kBrushless);
// Same API as SparkMAX
```

### Victor SPX / Talon SRX (older CTRE)
```java
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import com.ctre.phoenix.motorcontrol.NeutralMode;

WPI_TalonSRX talon = new WPI_TalonSRX(1);
talon.setNeutralMode(NeutralMode.Brake);
talon.setInverted(false);
talon.set(0.5);  // percent output

WPI_VictorSPX victor = new WPI_VictorSPX(2);
victor.follow(talon);  // follow talon
```

### PWM Motor Controllers (Spark, Talon, Victor — non-CAN)
```java
import edu.wpi.first.wpilibj.motorcontrol.Spark;
import edu.wpi.first.wpilibj.motorcontrol.PWMTalonFX;
import edu.wpi.first.wpilibj.motorcontrol.VictorSP;

Spark spark = new Spark(0);     // PWM port 0
spark.set(0.5);                 // -1.0 to 1.0
spark.setInverted(true);
spark.stopMotor();
```

---

## 8. Sensors

### Encoders (general WPILib)
```java
import edu.wpi.first.wpilibj.Encoder;

// Quadrature encoder on DIO ports
Encoder enc = new Encoder(0, 1);                   // channel A=0, B=1
enc.setDistancePerPulse(Math.PI * 0.1524 / 2048);  // circumference / pulses per rev
enc.setReverseDirection(false);

double distance = enc.getDistance();  // in your units (meters if set above)
double rate     = enc.getRate();      // units/sec
int    raw      = enc.get();          // raw pulse count
enc.reset();
```

### Gyroscopes

**NavX (AHRS) — most common FRC gyro:**
```java
import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.SPI;

AHRS gyro = new AHRS(SPI.Port.kMXP);  // MXP port on RoboRIO

double angle    = gyro.getAngle();         // cumulative angle (degrees), can exceed ±360
double yaw      = gyro.getYaw();           // -180 to 180, resets on zero
double pitch    = gyro.getPitch();
double roll     = gyro.getRoll();
double rate     = gyro.getRate();          // degrees/sec
gyro.reset();                              // zero the gyro
gyro.zeroYaw();
boolean isCalib = gyro.isCalibrating();    // wait for this to be false before zeroing
```

**Pigeon 2 (CTRE):**
```java
import com.ctre.phoenix6.hardware.Pigeon2;

Pigeon2 pigeon = new Pigeon2(0);  // CAN ID 0
double yaw   = pigeon.getYaw().getValueAsDouble();   // degrees
double pitch = pigeon.getPitch().getValueAsDouble();
double roll  = pigeon.getRoll().getValueAsDouble();
pigeon.reset();
// Get as Rotation2d for odometry:
Rotation2d heading = Rotation2d.fromDegrees(pigeon.getYaw().getValueAsDouble());
```

### Limit Switches
```java
import edu.wpi.first.wpilibj.DigitalInput;

DigitalInput limitSwitch = new DigitalInput(0);  // DIO port 0
boolean isTriggered = !limitSwitch.get();        // NOTE: usually normally-closed = inverted
```

### Analog Sensors (potentiometers, pressure sensors, ultrasonic)
```java
import edu.wpi.first.wpilibj.AnalogInput;

AnalogInput sensor = new AnalogInput(0);  // Analog port 0
double voltage    = sensor.getVoltage();  // 0-5V
double normalized = sensor.getValue();    // 0-4095 (12-bit ADC)
```

### Through-Bore Encoder (REV)
```java
// Plugged into DIO — use as absolute encoder for absolute position
import edu.wpi.first.wpilibj.DutyCycleEncoder;

DutyCycleEncoder absEnc = new DutyCycleEncoder(0);  // DIO port
absEnc.setPositionOffset(0.5);   // zero offset (0-1 range, fraction of full rotation)
double absPosition = absEnc.getAbsolutePosition();   // 0.0 to 1.0 (fraction of rotation)
double position    = absEnc.get();                   // rotations from zero offset
```

### Color Sensor (REV)
```java
import com.revrobotics.ColorSensorV3;
import edu.wpi.first.wpilibj.I2C;

ColorSensorV3 colorSensor = new ColorSensorV3(I2C.Port.kOnboard);
Color color     = colorSensor.getColor();
int proximity   = colorSensor.getProximity();  // 0-2047, higher = closer
```

---

## 9. Joysticks & Controllers

### XboxController (most common)
```java
import edu.wpi.first.wpilibj.XboxController;

XboxController controller = new XboxController(0);  // port 0

// Axes (return -1.0 to 1.0)
double leftY  = -controller.getLeftY();   // negate! up = negative by default
double leftX  =  controller.getLeftX();
double rightY = -controller.getRightY();
double rightX =  controller.getRightX();
double leftTrigger  = controller.getLeftTriggerAxis();   // 0 to 1
double rightTrigger = controller.getRightTriggerAxis();  // 0 to 1

// Buttons (return boolean)
boolean aBtn  = controller.getAButton();
boolean bBtn  = controller.getBButton();
boolean xBtn  = controller.getXButton();
boolean yBtn  = controller.getYButton();
boolean lb    = controller.getLeftBumper();
boolean rb    = controller.getRightBumper();
boolean start = controller.getStartButton();
boolean back  = controller.getBackButton();

// D-Pad (POV)
int pov = controller.getPOV();  // -1=none, 0=up, 90=right, 180=down, 270=left

// Rumble
controller.setRumble(XboxController.RumbleType.kBothRumble, 1.0);  // 0 to 1
controller.setRumble(XboxController.RumbleType.kBothRumble, 0.0);  // stop

// For Command-Based bindings use CommandXboxController instead:
import edu.wpi.first.wpilibj2.command.button.CommandXboxController;
CommandXboxController cmdCtrl = new CommandXboxController(0);
cmdCtrl.a().whileTrue(new IntakeCommand(m_intake));
cmdCtrl.b().onTrue(new InstantCommand(m_intake::stop));
cmdCtrl.leftBumper().whileTrue(new ShootCommand(m_shooter));
cmdCtrl.povUp().onTrue(new ArmUpCommand(m_arm));
```

### PS4 / Generic Joystick
```java
import edu.wpi.first.wpilibj.PS4Controller;
PS4Controller ps4 = new PS4Controller(1);
double leftY = -ps4.getLeftY();

import edu.wpi.first.wpilibj.Joystick;
Joystick stick = new Joystick(0);
double x = stick.getX();
double y = stick.getY();
boolean trigger = stick.getTrigger();
boolean btn2    = stick.getRawButton(2);
```

### Deadband (important — joysticks have drift!)
```java
import edu.wpi.first.math.MathUtil;

double input = controller.getLeftY();
double deadzoned = MathUtil.applyDeadband(input, 0.1);  // values within ±0.1 → 0

// Or manually:
double deadbanded = Math.abs(input) < 0.1 ? 0.0 : input;
```

---

## 10. Drivetrain Types

### Differential Drive (Tank/Arcade/Curvature)
```java
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

DifferentialDrive drive = new DifferentialDrive(leftMotor, rightMotor);

// Arcade drive (one stick for speed, one for rotation) — most common for teleop
drive.arcadeDrive(speed, rotation);            // inputs: -1.0 to 1.0, squareInputs=true by default
drive.arcadeDrive(speed, rotation, false);     // false = don't square inputs

// Tank drive (left stick → left wheels, right stick → right wheels)
drive.tankDrive(leftSpeed, rightSpeed);

// Curvature drive (constant-radius turns; better for high speed)
drive.curvatureDrive(speed, rotation, turnInPlace);

drive.stopMotor();
drive.feed();   // call if you're managing motors manually but want to avoid motor safety timeout
```

### Mecanum Drive
```java
import edu.wpi.first.wpilibj.drive.MecanumDrive;

MecanumDrive mecanum = new MecanumDrive(frontLeft, rearLeft, frontRight, rearRight);

// Field-oriented requires gyro angle
mecanum.driveCartesian(xSpeed, ySpeed, zRotation);
mecanum.driveCartesian(xSpeed, ySpeed, zRotation, gyroAngle);  // field-oriented
mecanum.drivePolar(magnitude, angle, zRotation);
```

### Swerve Drive (advanced — see SwerveModuleState, ChassisSpeeds)
```java
import edu.wpi.first.math.geometry.*;
import edu.wpi.first.math.kinematics.*;

// Define module positions relative to robot center
SwerveDriveKinematics kinematics = new SwerveDriveKinematics(
    new Translation2d( 0.381,  0.381),  // front-left  (meters)
    new Translation2d( 0.381, -0.381),  // front-right
    new Translation2d(-0.381,  0.381),  // rear-left
    new Translation2d(-0.381, -0.381)   // rear-right
);

// Convert driver inputs to module states
ChassisSpeeds speeds = new ChassisSpeeds(vxMetersPerSec, vyMetersPerSec, omegaRadPerSec);

// Field-oriented conversion (subtract current heading)
ChassisSpeeds fieldRelative = ChassisSpeeds.fromFieldRelativeSpeeds(
    vx, vy, omega, gyro.getRotation2d()
);

SwerveModuleState[] states = kinematics.toSwerveModuleStates(speeds);
SwerveDriveKinematics.desaturateWheelSpeeds(states, kMaxSpeedMetersPerSec);

// Each SwerveModule sets its drive and steer motors to match:
// states[0] = front-left, etc.
frontLeft.setDesiredState(states[0]);

// SwerveModuleState contains:
SwerveModuleState state = new SwerveModuleState(speedMetersPerSec, Rotation2d.fromDegrees(angle));
state = SwerveModuleState.optimize(state, currentAngle);  // flip direction if faster
```

### Odometry (tracking robot position on field)
```java
import edu.wpi.first.math.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.math.geometry.*;

DifferentialDriveOdometry odometry = new DifferentialDriveOdometry(
    gyro.getRotation2d(),
    leftEncoderMeters,
    rightEncoderMeters,
    new Pose2d(0, 0, new Rotation2d())  // initial position
);

// Call every loop:
odometry.update(gyro.getRotation2d(), leftEncoderMeters, rightEncoderMeters);

Pose2d pose     = odometry.getPoseMeters();
double x        = pose.getX();          // meters from start
double y        = pose.getY();
double heading  = pose.getRotation().getDegrees();

// Swerve odometry:
SwerveDriveOdometry swerveOdometry = new SwerveDriveOdometry(
    kinematics, gyro.getRotation2d(), modulePositions
);
swerveOdometry.update(gyro.getRotation2d(), modulePositions);
```

---

## 11. PID Control

### WPILib PIDController (runs in robot code, ~20 ms loop)
```java
import edu.wpi.first.math.controller.PIDController;

PIDController pid = new PIDController(kP, kI, kD);
pid.setTolerance(0.05);             // within 5 cm = "at setpoint"
pid.setIntegratorRange(-0.3, 0.3);  // clamp integral term

// In periodic/execute:
double output = pid.calculate(measurement, setpoint);
// measurement = current sensor value; setpoint = target value
motor.set(output);

// Check if at goal
if (pid.atSetpoint()) { ... }

pid.reset();  // clear integral accumulator
```

### ProfiledPIDController (with motion profiling — smoother motion)
```java
import edu.wpi.first.math.controller.ProfiledPIDController;
import edu.wpi.first.math.trajectory.TrapezoidProfile;

TrapezoidProfile.Constraints constraints =
    new TrapezoidProfile.Constraints(maxVelocity, maxAcceleration);

ProfiledPIDController ppid = new ProfiledPIDController(kP, kI, kD, constraints);
ppid.setGoal(targetPosition);   // or setGoal(new TrapezoidProfile.State(pos, vel))

double output = ppid.calculate(currentPosition);
```

### Feedforward (combine with PID for better performance)
```java
import edu.wpi.first.math.controller.SimpleMotorFeedforward;
import edu.wpi.first.math.controller.ArmFeedforward;
import edu.wpi.first.math.controller.ElevatorFeedforward;

// SimpleMotorFeedforward: output = kS * sign(v) + kV * v + kA * a
SimpleMotorFeedforward ff = new SimpleMotorFeedforward(kS, kV, kA);
double ffOutput = ff.calculate(velocitySetpoint);           // steady-state
double ffOutput2 = ff.calculate(velocitySetpoint, accel);  // with acceleration

// ArmFeedforward: accounts for gravity (cosine of angle)
ArmFeedforward armFF = new ArmFeedforward(kS, kG, kV, kA);
double armFFOut = armFF.calculate(angleRadians, velocitySetpoint);

// ElevatorFeedforward: accounts for constant gravity load
ElevatorFeedforward elevFF = new ElevatorFeedforward(kS, kG, kV, kA);
double elevOut = elevFF.calculate(velocitySetpoint);

// Combine PID + FF:
double output = pid.calculate(measurement, setpoint) + ff.calculate(setpoint);
```

### SysId (WPILib system identification — how to get kS, kV, kA, kP)
```java
// SysId runs special routines that apply voltage ramps and logs data
// Then you analyze in the WPILib SysId tool to get feedforward constants
// Minimal setup in your subsystem:

import edu.wpi.first.wpilibj2.command.sysid.SysIdRoutine;
import edu.wpi.first.units.*;

SysIdRoutine sysIdRoutine = new SysIdRoutine(
    new SysIdRoutine.Config(),
    new SysIdRoutine.Mechanism(
        (voltage) -> motor.setVoltage(voltage.in(Units.Volts)),
        log -> {
            log.motor("drive-left")
               .voltage(Units.Volts.of(motor.get() * RobotController.getBatteryVoltage()))
               .linearPosition(Units.Meters.of(encoder.getDistance()))
               .linearVelocity(Units.MetersPerSecond.of(encoder.getRate()));
        },
        this
    )
);

// Bind to buttons in RobotContainer for running routines:
// sysIdRoutine.quasistatic(SysIdRoutine.Direction.kForward)
// sysIdRoutine.dynamic(SysIdRoutine.Direction.kForward)
```

---

## 12. PathPlanner & Autonomous

### PathPlanner (most popular FRC path-following library)
```java
// build.gradle dependency:
// implementation "com.pathplanner.lib:pathplannerlib:YYYY.X.X"

import com.pathplanner.lib.auto.AutoBuilder;
import com.pathplanner.lib.util.HolonomicPathFollowerConfig;
import com.pathplanner.lib.util.PIDConstants;
import com.pathplanner.lib.util.ReplanningConfig;
import com.pathplanner.lib.commands.PathPlannerAuto;

// Configure AutoBuilder ONCE in DriveSubsystem constructor (swerve example):
AutoBuilder.configureHolonomic(
    this::getPose,                   // Pose2d supplier
    this::resetOdometry,             // Pose2d consumer (reset odometry to this)
    this::getRobotRelativeSpeeds,    // ChassisSpeeds supplier (robot-relative)
    this::driveRobotRelative,        // ChassisSpeeds consumer
    new HolonomicPathFollowerConfig(
        new PIDConstants(5.0, 0, 0),  // translation PID
        new PIDConstants(5.0, 0, 0),  // rotation PID
        kMaxModuleSpeedMetersPerSec,
        kDriveBaseRadius,             // meters from center to furthest module
        new ReplanningConfig()
    ),
    () -> {
        // Flip path for red alliance (field is mirrored)
        var alliance = DriverStation.getAlliance();
        return alliance.isPresent() && alliance.get() == DriverStation.Alliance.Red;
    },
    this  // reference to drive subsystem
);

// Register named commands (used in PathPlanner GUI as event markers)
NamedCommands.registerCommand("IntakeDown",  new IntakeDownCommand(m_intake));
NamedCommands.registerCommand("Shoot",       new ShootCommand(m_shooter));

// In RobotContainer:
// Auto chooser (reads paths from src/main/deploy/pathplanner/autos/)
private final SendableChooser<Command> m_autoChooser = AutoBuilder.buildAutoChooser();

public Command getAutonomousCommand() {
    return m_autoChooser.getSelected();
    // OR: new PathPlannerAuto("MyAutoName")
}
```

### WPILib Trajectory Following (built-in, no external library)
```java
import edu.wpi.first.math.trajectory.*;
import edu.wpi.first.math.controller.*;
import edu.wpi.first.wpilibj2.command.RamseteCommand;

// Generate trajectory
TrajectoryConfig config = new TrajectoryConfig(
    maxVelocityMetersPerSec,
    maxAccelMetersPerSecSq
).setKinematics(m_drive.getKinematics());

Trajectory trajectory = TrajectoryGenerator.generateTrajectory(
    new Pose2d(0, 0, new Rotation2d(0)),
    List.of(new Translation2d(1, 0), new Translation2d(2, 1)),
    new Pose2d(3, 0, new Rotation2d(0)),
    config
);

// Follow with RAMSETE (for differential drive)
RamseteCommand ramseteCmd = new RamseteCommand(
    trajectory,
    m_drive::getPose,
    new RamseteController(kRamseteB, kRamseteZeta),
    new SimpleMotorFeedforward(kS, kV, kA),
    m_drive.getKinematics(),
    m_drive::getWheelSpeeds,
    new PIDController(kPDriveVel, 0, 0),
    new PIDController(kPDriveVel, 0, 0),
    m_drive::tankDriveVolts,
    m_drive
);

return ramseteCmd.andThen(() -> m_drive.tankDriveVolts(0, 0));
```

### Auto Chooser (Sendable)
```java
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

SendableChooser<Command> chooser = new SendableChooser<>();
chooser.setDefaultOption("Do Nothing", new InstantCommand());
chooser.addOption("Drive Forward", new DriveForwardCommand(m_drive));
chooser.addOption("Two Piece",     new PathPlannerAuto("TwoPiece"));
SmartDashboard.putData("Auto Chooser", chooser);

// In autonomousInit:
Command auto = chooser.getSelected();
if (auto != null) auto.schedule();
```

---

## 13. SmartDashboard & Shuffleboard

### SmartDashboard (simple key-value)
```java
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// Put values (call in periodic)
SmartDashboard.putNumber("Shooter RPM",   m_shooter.getRPM());
SmartDashboard.putBoolean("Has Note",     m_intake.hasNote());
SmartDashboard.putString("Auto Mode",     m_auto.getName());

// Put a Sendable (motor, PIDController, chooser, etc.)
SmartDashboard.putData("Drive PID",       m_drivePID);
SmartDashboard.putData("Auto Chooser",    m_chooser);

// Get values (for tuning from dashboard)
double p = SmartDashboard.getNumber("kP", 0.0);  // second arg = default if not found
```

### Shuffleboard (layout control)
```java
import edu.wpi.first.wpilibj.shuffleboard.*;

// Add widget to tab
ShuffleboardTab tab = Shuffleboard.getTab("Drivetrain");
tab.add("Left Encoder", m_leftEncoder).withWidget(BuiltInWidgets.kEncoder);
tab.addNumber("Speed", () -> m_drive.getSpeed())
   .withPosition(0, 0)
   .withSize(2, 1);

// Persistent value (survives DS restart)
NetworkTableEntry kpEntry = tab.add("kP", 0.1)
    .withWidget(BuiltInWidgets.kTextView)
    .getEntry();

// Read it back each loop:
double kp = kpEntry.getDouble(0.1);
```

---

## 14. NetworkTables

NetworkTables is the underlying pub/sub system connecting the robot to dashboards, co-processors, etc.

```java
import edu.wpi.first.networktables.*;

// Get the default instance (connects to robot)
NetworkTableInstance inst = NetworkTableInstance.getDefault();

// Publisher (robot → dashboard / co-processor)
NetworkTable table = inst.getTable("MyTable");
DoublePublisher shooterRPM = table.getDoubleTopic("shooterRPM").publish();
shooterRPM.set(5000.0);

// Subscriber (dashboard / co-processor → robot)
DoubleSubscriber targetX = table.getDoubleTopic("targetX").subscribe(0.0);
double x = targetX.get();  // returns default if no value published

// Limelight example (uses NT3-style raw entries):
NetworkTable limelight = inst.getTable("limelight");
double tv = limelight.getEntry("tv").getDouble(0); // 1 = target found
double tx = limelight.getEntry("tx").getDouble(0); // horizontal offset degrees
limelight.getEntry("ledMode").setNumber(1);         // force LEDs on

// Listening for changes (callback)
targetX.subscribe(0.0);  // then poll with targetX.get() each loop, or use:
inst.addListener(
    table.getDoubleTopic("targetX").subscribe(0.0),
    EnumSet.of(NetworkTableEvent.Kind.kValueAll),
    event -> System.out.println("New value: " + event.valueData.value.getDouble())
);
```

---

## 15. Vision (Limelight & PhotonVision)

### Limelight (simplest setup — reads via NetworkTables)
```java
NetworkTable limelight = NetworkTableInstance.getDefault().getTable("limelight");

// Key entries
double tv  = limelight.getEntry("tv").getDouble(0);  // 1 = target valid
double tx  = limelight.getEntry("tx").getDouble(0);  // horiz offset (degrees, + = right)
double ty  = limelight.getEntry("ty").getDouble(0);  // vert offset (degrees, + = up)
double ta  = limelight.getEntry("ta").getDouble(0);  // target area (% of image, 0-100)
double tid = limelight.getEntry("tid").getDouble(-1); // AprilTag ID (-1 = none)

// Get robot pose from MegaTag2 (Limelight 3/4 with known field layout)
double[] botpose = limelight.getEntry("botpose_wpiblue").getDoubleArray(new double[7]);
// [x, y, z, roll, pitch, yaw, latency_ms]
if (botpose.length >= 6) {
    Pose2d visionPose = new Pose2d(botpose[0], botpose[1],
                                   Rotation2d.fromDegrees(botpose[5]));
    double latencySeconds = botpose[6] / 1000.0;
    m_poseEstimator.addVisionMeasurement(visionPose,
        Timer.getFPGATimestamp() - latencySeconds);
}

// LED / pipeline control
limelight.getEntry("ledMode").setNumber(0);    // pipeline default
limelight.getEntry("ledMode").setNumber(1);    // off
limelight.getEntry("ledMode").setNumber(2);    // blink
limelight.getEntry("ledMode").setNumber(3);    // on
limelight.getEntry("pipeline").setNumber(0);   // switch pipeline
limelight.getEntry("camMode").setNumber(0);    // vision mode
limelight.getEntry("camMode").setNumber(1);    // driver cam mode
```

### PhotonVision (more flexible, runs on co-processor)
```java
import org.photonvision.*;
import org.photonvision.targeting.*;

PhotonCamera camera = new PhotonCamera("photonvision");  // camera name in PV UI

PhotonPipelineResult result = camera.getLatestResult();

if (result.hasTargets()) {
    PhotonTrackedTarget target = result.getBestTarget();
    double yaw    = target.getYaw();     // degrees, + = right
    double pitch  = target.getPitch();
    double area   = target.getArea();
    int    id     = target.getFiducialId();  // AprilTag ID

    // 3D pose relative to camera
    Transform3d camToTarget = target.getBestCameraToTarget();
}

// Pose estimation with PhotonPoseEstimator
PhotonPoseEstimator poseEstimator = new PhotonPoseEstimator(
    AprilTagFieldLayout.loadFromResource(AprilTagFields.k2024Crescendo.m_resourceFile),
    PoseStrategy.MULTI_TAG_PNP_ON_COPROCESSOR,
    camera,
    robotToCameraTransform
);

Optional<EstimatedRobotPose> estPose = poseEstimator.update();
estPose.ifPresent(est -> {
    m_poseEstimator.addVisionMeasurement(
        est.estimatedPose.toPose2d(),
        est.timestampSeconds
    );
});
```

### SwerveDrivePoseEstimator (fuses odometry + vision)
```java
import edu.wpi.first.math.estimator.SwerveDrivePoseEstimator;

SwerveDrivePoseEstimator poseEstimator = new SwerveDrivePoseEstimator(
    kinematics,
    gyro.getRotation2d(),
    modulePositions,
    new Pose2d(),
    // Standard deviations: [x, y, theta] — lower = trust more
    VecBuilder.fill(0.05, 0.05, Units.degreesToRadians(5)),   // odometry
    VecBuilder.fill(0.5,  0.5,  Units.degreesToRadians(30))   // vision
);

// In periodic:
poseEstimator.update(gyro.getRotation2d(), modulePositions);

// When vision measurement arrives:
poseEstimator.addVisionMeasurement(visionPose, timestampSeconds);
// Or with custom std devs for this measurement:
poseEstimator.addVisionMeasurement(visionPose, timestamp,
    VecBuilder.fill(0.3, 0.3, Units.degreesToRadians(15)));
```

---

## 16. Pneumatics

### CTRE Pneumatics Control Module (PCM)
```java
import edu.wpi.first.wpilibj.PneumaticsModuleType;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Compressor;

// Compressor (auto-start by default — starts when pressure < threshold)
Compressor compressor = new Compressor(0, PneumaticsModuleType.CTREPCM);
compressor.enableDigital();    // auto-manage using pressure switch
compressor.disable();

// Single-acting solenoid (one coil, spring return)
Solenoid single = new Solenoid(PneumaticsModuleType.CTREPCM, 0);  // channel 0
single.set(true);    // extend
single.set(false);   // retract
single.toggle();

// Double-acting solenoid (two coils, stays where put)
DoubleSolenoid doubleSol = new DoubleSolenoid(
    PneumaticsModuleType.CTREPCM, 0, 1);  // forward=ch0, reverse=ch1
doubleSol.set(DoubleSolenoid.Value.kForward);
doubleSol.set(DoubleSolenoid.Value.kReverse);
doubleSol.set(DoubleSolenoid.Value.kOff);     // neutral (stays in place)
doubleSol.toggle();
```

### REV Pneumatics Hub (PH)
```java
// Same API, just change module type:
Solenoid single = new Solenoid(PneumaticsModuleType.REVPH, 0);
Compressor comp  = new Compressor(1, PneumaticsModuleType.REVPH);  // CAN ID 1
comp.enableAnalog(60, 120);  // min/max PSI for analog pressure sensor
```

---

## 17. CAN Bus & Power Distribution

### Power Distribution Panel / Hub
```java
import edu.wpi.first.wpilibj.PowerDistribution;

PowerDistribution pdh = new PowerDistribution(1, PowerDistribution.ModuleType.kRev);
// Or for CTRE PDP:
PowerDistribution pdp = new PowerDistribution(0, PowerDistribution.ModuleType.kCTRE);

double totalCurrent = pdh.getTotalCurrent();   // amps
double voltage      = pdh.getVoltage();         // battery voltage
double ch0Current   = pdh.getCurrent(0);        // amps on channel 0
double temp         = pdh.getTemperature();     // Celsius
```

### RoboRIO & CAN Bus Diagnostics
```java
import edu.wpi.first.wpilibj.RobotController;

double batteryVoltage = RobotController.getBatteryVoltage();
boolean isBrownedOut  = RobotController.isBrownedOut();
double fpgaTime       = RobotController.getFPGATime() / 1e6;  // seconds

// CANivore (CTRE's USB-CAN adapter for Phoenix 6)
// Just use canivore name string in device constructor:
TalonFX motor = new TalonFX(1, "canivore1");
Pigeon2 imu   = new Pigeon2(0, "canivore1");
```

---

## 18. Robot Simulation

WPILib includes a simulation framework that lets you test robot code without hardware.

```java
// In your Subsystem, add simulation counterparts:
import edu.wpi.first.wpilibj.simulation.*;
import edu.wpi.first.math.system.plant.*;

// Simulate a DCMotor (for physics-based sim)
DCMotor gearboxSim = DCMotor.getNEO(1);

// FlywheelSim — models a flywheel
FlywheelSim flywheelSim = new FlywheelSim(
    gearboxSim,
    gearRatio,
    momentOfInertia  // kg*m^2
);

// ElevatorSim
ElevatorSim elevSim = new ElevatorSim(
    gearboxSim, gearRatio, massKg,
    drumRadiusMeters, minHeightMeters, maxHeightMeters,
    simulateGravity, startingHeightMeters
);

// In simulationPeriodic() (called automatically when in sim):
@Override
public void simulationPeriodic() {
    // Set input to your sim from motor controller voltage
    flywheelSim.setInput(m_motor.get() * RobotController.getBatteryVoltage());
    flywheelSim.update(0.020);  // 20 ms step

    // Read sim outputs back to encoder sim
    m_encoderSim.setRate(flywheelSim.getAngularVelocityRPM() / 60.0);
}
```

### Simulation in VS Code
- Run simulation: `./gradlew simulateJava` (or use the WPILib palette command)
- Connect Driver Station to `localhost`
- View in Glass (WPILib visualization tool) for field views, graphs, etc.

---

## 19. Vendor Libraries Cheatsheet

| Library | vendordep URL / file | Docs |
|---|---|---|
| CTRE Phoenix 6 | https://maven.ctr-electronics.com/release/com/ctre/phoenix6/latest/Phoenix6-frc2025-latest.json | ctre-phoenix6.github.io |
| CTRE Phoenix 5 | https://maven.ctr-electronics.com/release/com/ctre/phoenix/Phoenix5-frc2025-latest.json | v5.ctr-electronics.com |
| REV Robotics | https://software-metadata.revrobotics.com/REVLib-2025.json | docs.revrobotics.com |
| NavX (Kauai Labs) | https://dev.studica.com/releases/2025/NavX.json | pdocs.kauailabs.com |
| PathPlanner | https://3015rangerrobotics.github.io/pathplannerlib/PathplannerLib.json | pathplanner.me/app |
| PhotonVision | https://maven.photonvision.org/repository/internal/org/photonvision/photonlib-json/1.0/photonlib-json-1.0.json | docs.photonvision.org |
| Choreo | Comes with WPILib 2025+ | choreo.autos |

**Installing vendordep in VS Code:**
`Ctrl+Shift+P` → `WPILib: Manage Vendor Libraries` → `Install new library (online)` → paste URL

---

## 20. Common Gotchas & Best Practices

### Motor Safety Timeout
```java
// WPILib motor safety stops motors if set() isn't called every ~100 ms
// DifferentialDrive calls feed() automatically
// If you drive motors directly, disable safety or call feed():
motor.setSafetyEnabled(false);
// OR call motor.feed() every loop if you want it enabled
```

### Inversion & Direction
```java
// Always double-check: positive input should mean forward/up/intake-in
// Right side of differential drive usually needs inversion:
rightMotor.setInverted(true);
// CTRE Phoenix 6: InvertedValue.Clockwise_Positive or CounterClockwise_Positive
// REV SparkMAX: setInverted(true/false)
```

### Alliance-Relative Coordinates
```java
// In 2024+ the field origin is always at Blue Alliance wall
// Mirror X for Red Alliance:
if (DriverStation.getAlliance().orElse(Alliance.Blue) == Alliance.Red) {
    pose = new Pose2d(fieldLengthMeters - pose.getX(), pose.getY(),
                     pose.getRotation().plus(Rotation2d.fromDegrees(180)));
}
// PathPlanner handles this automatically with the alliance flip lambda
```

### `burnFlash()` on SparkMAX/SparkFlex
```java
// Only call once after all configuration, not every time robotInit() runs
// Flash has limited write cycles (~10,000)
// Pattern: configure once in constructor, then burnFlash()
motor.restoreFactoryDefaults();
motor.setIdleMode(IdleMode.kBrake);
motor.setSmartCurrentLimit(40);
motor.burnFlash();  // <-- last line of constructor
```

### Avoiding Loop Overruns
```java
// Things that block or are slow (DON'T do in periodic):
// - Thread.sleep()
// - File I/O
// - Waiting for CAN status frames in a tight loop
// - Creating new objects in hot paths (allocates memory, triggers GC)

// If you see "Loop time of 0.02s overrun" on dashboard:
// - Check for blocking calls
// - Use LoopOverrunNotifier or check Timer.getFPGATime() deltas
```

### require() / addRequirements()
```java
// ALWAYS call addRequirements(subsystem) in Command constructor
// Without it, two commands can fight over the same hardware silently
public IntakeCommand(IntakeSubsystem intake) {
    m_intake = intake;
    addRequirements(m_intake);  // Don't forget!
}
```

### DriverStation & FMS
```java
import edu.wpi.first.wpilibj.DriverStation;

boolean isAuto      = DriverStation.isAutonomous();
boolean isTeleop    = DriverStation.isTeleop();
boolean isEnabled   = DriverStation.isEnabled();
boolean isFMSAttached = DriverStation.isFMSAttached();
double  matchTime   = DriverStation.getMatchTime();  // seconds remaining (-1 if unknown)

Optional<Alliance> alliance = DriverStation.getAlliance();
alliance.ifPresent(a -> {
    if (a == DriverStation.Alliance.Red) { /* red alliance logic */ }
});
```

### Units Library (WPILib 2024+)
```java
import edu.wpi.first.units.*;
import static edu.wpi.first.units.Units.*;

// Use typed units to avoid m vs cm vs in bugs
Measure<Distance>  dist  = Meters.of(1.5);
Measure<Velocity<Distance>> vel = MetersPerSecond.of(3.0);
Measure<Angle>     angle = Degrees.of(90);

double meters   = dist.in(Meters);
double inches   = dist.in(Inches);
double radians  = angle.in(Radians);
```

### Useful WPILib Utilities
```java
import edu.wpi.first.math.MathUtil;

MathUtil.clamp(value, min, max);          // clamp to range
MathUtil.applyDeadband(value, deadband);  // zero small inputs
MathUtil.inputModulus(value, -Math.PI, Math.PI);  // wrap angle to range
MathUtil.interpolate(startValue, endValue, t);     // linear interpolate

import edu.wpi.first.math.filter.SlewRateLimiter;
SlewRateLimiter limiter = new SlewRateLimiter(2.0);  // max 2 units/sec change
double smoothed = limiter.calculate(rawInput);        // call every loop

import edu.wpi.first.math.filter.Debouncer;
Debouncer debouncer = new Debouncer(0.1, Debouncer.DebounceType.kBoth);
boolean stable = debouncer.calculate(sensor.get());  // must be stable for 0.1s
```

---

*Reference written for FRC 2025 season. WPILib and vendor library APIs change yearly — always check the official docs and changelogs.*